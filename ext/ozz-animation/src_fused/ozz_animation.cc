// This file is autogenerated. Do not modify it.

// Including animation.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/animation.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/log.h"
#include "ozz/base/maths/math_archive.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/memory/allocator.h"

#include <cassert>
#include <cstring>

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/runtime/animation_keyframe.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_
#define OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

namespace ozz {
namespace animation {

// Define animation key frame types (translation, rotation, scale). Every type
// as the same base made of the key time and it's track. This is required as
// key frames are not sorted per track, but sorted by time to favor cache
// coherency.
// Key frame values are compressed, according on their type. Decompression is
// efficient because it's done on SoA data and cached during sampling.

// Defines the translation key frame type.
// Translation values are stored as half precision floats with 16 bits per
// component.
struct TranslationKey {
  float time;
  uint16_t track;
  uint16_t value[3];
};

// Defines the rotation key frame type.
// Rotation value is a quaternion. Quaternion are normalized, which means each
// component is in range [0:1]. This property allows to quantize the 3
// components to 3 signed integer 16 bits values. The 4th component is restored
// at runtime, using the knowledge that |w| = sqrt(1 - (a^2 + b^2 + c^2)).
// The sign of this 4th component is stored using 1 bit taken from the track
// member.
//
// In more details, compression algorithm stores the 3 smallest components of
// the quaternion and restores the largest. The 3 smallest can be pre-multiplied
// by sqrt(2) to gain some precision indeed.
//
// Quantization could be reduced to 11-11-10 bits as often used for animation
// key frames, but in this case RotationKey structure would induce 16 bits of
// padding.
struct RotationKey {
  float time;
  uint16_t track : 13;   // The track this key frame belongs to.
  uint16_t largest : 2;  // The largest component of the quaternion.
  uint16_t sign : 1;     // The sign of the largest component. 1 for negative.
  int16_t value[3];      // The quantized value of the 3 smallest components.
};

// Defines the scale key frame type.
// Scale values are stored as half precision floats with 16 bits per
// component.
struct ScaleKey {
  float time;
  uint16_t track;
  uint16_t value[3];
};
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_


namespace ozz {
namespace animation {

Animation::Animation() : duration_(0.f), num_tracks_(0), name_(NULL) {}

Animation::~Animation() { Deallocate(); }

void Animation::Allocate(size_t name_len, size_t _translation_count,
                         size_t _rotation_count, size_t _scale_count) {
  // Distributes buffer memory while ensuring proper alignment (serves larger
  // alignment values first).
  OZZ_STATIC_ASSERT(OZZ_ALIGN_OF(TranslationKey) >= OZZ_ALIGN_OF(RotationKey) &&
                    OZZ_ALIGN_OF(RotationKey) >= OZZ_ALIGN_OF(ScaleKey) &&
                    OZZ_ALIGN_OF(ScaleKey) >= OZZ_ALIGN_OF(char));

  assert(name_ == NULL && translations_.Size() == 0 && rotations_.Size() == 0 &&
         scales_.Size() == 0);

  // Compute overall size and allocate a single buffer for all the data.
  const size_t buffer_size = (name_len > 0 ? name_len + 1 : 0) +
                             _translation_count * sizeof(TranslationKey) +
                             _rotation_count * sizeof(RotationKey) +
                             _scale_count * sizeof(ScaleKey);
  char* buffer = memory::default_allocator()->Allocate<char>(buffer_size);

  // Fix up pointers
  translations_.begin = reinterpret_cast<TranslationKey*>(buffer);
  assert(math::IsAligned(translations_.begin, OZZ_ALIGN_OF(TranslationKey)));
  buffer += _translation_count * sizeof(TranslationKey);
  translations_.end = reinterpret_cast<TranslationKey*>(buffer);

  rotations_.begin = reinterpret_cast<RotationKey*>(buffer);
  assert(math::IsAligned(rotations_.begin, OZZ_ALIGN_OF(RotationKey)));
  buffer += _rotation_count * sizeof(RotationKey);
  rotations_.end = reinterpret_cast<RotationKey*>(buffer);

  scales_.begin = reinterpret_cast<ScaleKey*>(buffer);
  assert(math::IsAligned(scales_.begin, OZZ_ALIGN_OF(ScaleKey)));
  buffer += _scale_count * sizeof(ScaleKey);
  scales_.end = reinterpret_cast<ScaleKey*>(buffer);

  // Let name be NULL if animation has no name. Allows to avoid allocating this
  // buffer in the constructor of empty animations.
  name_ = reinterpret_cast<char*>(name_len > 0 ? buffer : NULL);
  assert(math::IsAligned(name_, OZZ_ALIGN_OF(char)));
}

void Animation::Deallocate() {
  memory::default_allocator()->Deallocate(translations_.begin);

  name_ = NULL;
  translations_ = ozz::Range<TranslationKey>();
  rotations_ = ozz::Range<RotationKey>();
  scales_ = ozz::Range<ScaleKey>();
}

size_t Animation::size() const {
  const size_t size =
      sizeof(*this) + translations_.Size() + rotations_.Size() + scales_.Size();
  return size;
}

void Animation::Save(ozz::io::OArchive& _archive) const {
  _archive << duration_;
  _archive << static_cast<int32_t>(num_tracks_);

  const size_t name_len = name_ ? std::strlen(name_) : 0;
  _archive << static_cast<int32_t>(name_len);

  const ptrdiff_t translation_count = translations_.Count();
  _archive << static_cast<int32_t>(translation_count);
  const ptrdiff_t rotation_count = rotations_.Count();
  _archive << static_cast<int32_t>(rotation_count);
  const ptrdiff_t scale_count = scales_.Count();
  _archive << static_cast<int32_t>(scale_count);

  _archive << ozz::io::MakeArray(name_, name_len);

  for (ptrdiff_t i = 0; i < translation_count; ++i) {
    const TranslationKey& key = translations_.begin[i];
    _archive << key.time;
    _archive << key.track;
    _archive << ozz::io::MakeArray(key.value);
  }

  for (ptrdiff_t i = 0; i < rotation_count; ++i) {
    const RotationKey& key = rotations_.begin[i];
    _archive << key.time;
    uint16_t track = key.track;
    _archive << track;
    uint8_t largest = key.largest;
    _archive << largest;
    bool sign = key.sign;
    _archive << sign;
    _archive << ozz::io::MakeArray(key.value);
  }

  for (ptrdiff_t i = 0; i < scale_count; ++i) {
    const ScaleKey& key = scales_.begin[i];
    _archive << key.time;
    _archive << key.track;
    _archive << ozz::io::MakeArray(key.value);
  }
}

void Animation::Load(ozz::io::IArchive& _archive, uint32_t _version) {
  // Destroy animation in case it was already used before.
  Deallocate();
  duration_ = 0.f;
  num_tracks_ = 0;

  // No retro-compatibility with anterior versions.
  if (_version != 4) {
    log::Err() << "Unsupported Animation version " << _version << "."
               << std::endl;
    return;
  }

  _archive >> duration_;

  int32_t num_tracks;
  _archive >> num_tracks;
  num_tracks_ = num_tracks;

  int32_t name_len;
  _archive >> name_len;
  int32_t translation_count;
  _archive >> translation_count;
  int32_t rotation_count;
  _archive >> rotation_count;
  int32_t scale_count;
  _archive >> scale_count;

  Allocate(name_len, translation_count, rotation_count, scale_count);

  if (name_) {  // NULL name_ is supported.
    _archive >> ozz::io::MakeArray(name_, name_len);
    name_[name_len] = 0;
  }

  for (int i = 0; i < translation_count; ++i) {
    TranslationKey& key = translations_.begin[i];
    _archive >> key.time;
    _archive >> key.track;
    _archive >> ozz::io::MakeArray(key.value);
  }

  for (int i = 0; i < rotation_count; ++i) {
    RotationKey& key = rotations_.begin[i];
    _archive >> key.time;
    uint16_t track;
    _archive >> track;
    key.track = track;
    uint8_t largest;
    _archive >> largest;
    key.largest = largest & 3;
    bool sign;
    _archive >> sign;
    key.sign = sign & 1;
    _archive >> ozz::io::MakeArray(key.value);
  }

  for (int i = 0; i < scale_count; ++i) {
    ScaleKey& key = scales_.begin[i];
    _archive >> key.time;
    _archive >> key.track;
    _archive >> ozz::io::MakeArray(key.value);
  }
}
}  // namespace animation
}  // namespace ozz

// Including blending_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/blending_job.h"

#include <cassert>
#include <cstddef>

#include "ozz/animation/runtime/skeleton.h"

#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/soa_transform.h"

namespace ozz {
namespace animation {

BlendingJob::Layer::Layer() : weight(0.f) {}

BlendingJob::BlendingJob() : threshold(.1f) {}

namespace {
bool ValidateLayer(const BlendingJob::Layer& _layer, ptrdiff_t _min_range) {
  bool valid = true;

  // Tests transforms validity.
  valid &= _layer.transform.begin != NULL;
  valid &= _layer.transform.end >= _layer.transform.begin;
  valid &= _layer.transform.end - _layer.transform.begin >= _min_range;

  // Joint weights are optional.
  if (_layer.joint_weights.begin != NULL) {
    valid &= _layer.joint_weights.end >= _layer.joint_weights.begin;
    valid &=
        _layer.joint_weights.end - _layer.joint_weights.begin >= _min_range;
  } else {
    valid &= _layer.joint_weights.end == NULL;
  }
  return valid;
}
}  // namespace

bool BlendingJob::Validate() const {
  // Don't need any early out, as jobs are valid in most of the performance
  // critical cases.
  // Tests are written in multiple lines in order to avoid branches.
  bool valid = true;

  // Test for valid threshold).
  valid &= threshold > 0.f;

  // Test for NULL begin pointers.
  // Blending layers are mandatory, additive aren't.
  valid &= bind_pose.begin != NULL;
  valid &= output.begin != NULL;

  // Test ranges are valid (implicitly test for NULL end pointers).
  valid &= bind_pose.end >= bind_pose.begin;
  valid &= output.end >= output.begin;

  // The bind pose size defines the ranges of transforms to blend, so all
  // other buffers should be bigger.
  const ptrdiff_t min_range = bind_pose.end - bind_pose.begin;
  valid &= output.end - output.begin >= min_range;

  // Blend layers are optional.
  if (layers.begin != NULL) {
    valid &= layers.end >= layers.begin;
  } else {
    valid &= layers.end == NULL;
  }

  // Validates layers.
  for (const Layer* layer = layers.begin; layers.begin && layer < layers.end;
       ++layer) {
    valid &= ValidateLayer(*layer, min_range);
  }

  // Additive layers are optional.
  if (additive_layers.begin != NULL) {
    valid &= additive_layers.end >= additive_layers.begin;
  } else {
    valid &= additive_layers.end == NULL;
  }

  // Validates additive layers.
  for (const Layer* layer = additive_layers.begin;
       additive_layers.begin &&
       layer < additive_layers.end;  // Handles NULL pointers.
       ++layer) {
    valid &= ValidateLayer(*layer, min_range);
  }

  return valid;
}

namespace {

// Macro that defines the process of blending the 1st pass.
#define OZZ_BLEND_1ST_PASS(_in, _simd_weight, _out)     \
  {                                                     \
    _out->translation = _in.translation * _simd_weight; \
    _out->rotation = _in.rotation * _simd_weight;       \
    _out->scale = _in.scale * _simd_weight;             \
  }

// Macro that defines the process of blending any pass but the first.
#define OZZ_BLEND_N_PASS(_in, _simd_weight, _out)                           \
  {                                                                         \
    /* Blends translation. */                                               \
    _out->translation = _out->translation + _in.translation * _simd_weight; \
    /* Blends rotations, negates opposed quaternions to be sure to choose*/ \
    /* the shortest path between the two.*/                                 \
    const math::SimdFloat4 dot = _out->rotation.x * _in.rotation.x +        \
                                 _out->rotation.y * _in.rotation.y +        \
                                 _out->rotation.z * _in.rotation.z +        \
                                 _out->rotation.w * _in.rotation.w;         \
    const math::SimdInt4 sign = math::Sign(dot);                            \
    const math::SoaQuaternion rotation = {                                  \
        math::Xor(_in.rotation.x, sign), math::Xor(_in.rotation.y, sign),   \
        math::Xor(_in.rotation.z, sign), math::Xor(_in.rotation.w, sign)};  \
    _out->rotation = _out->rotation + rotation * _simd_weight;              \
    /* Blends scales.*/                                                     \
    _out->scale = _out->scale + _in.scale * _simd_weight;                   \
  }

// Macro that defines the process of adding a pass.
#define OZZ_ADD_PASS(_in, _simd_weight, _out)                                \
  {                                                                          \
    _out.translation = _out.translation + _in.translation * _simd_weight;    \
    /* Interpolate quaternion between identity and src.rotation.*/           \
    /* Quaternion sign is fixed up, so that lerp takes the shortest path.*/  \
    const math::SimdInt4 sign = math::Sign(_in.rotation.w);                  \
    const math::SoaQuaternion rotation = {                                   \
        math::Xor(_in.rotation.x, sign), math::Xor(_in.rotation.y, sign),    \
        math::Xor(_in.rotation.z, sign), math::Xor(_in.rotation.w, sign)};   \
    const math::SoaQuaternion interp_quat = {                                \
        rotation.x * _simd_weight, rotation.y * _simd_weight,                \
        rotation.z * _simd_weight, (rotation.w - one) * _simd_weight + one}; \
    _out.rotation = NormalizeEst(interp_quat) * _out.rotation;               \
    _out.scale =                                                             \
        _out.scale * (one_minus_weight_f3 + (_in.scale * _simd_weight));     \
  }

// Macro that defines the process of subtracting a pass.
#define OZZ_SUB_PASS(_in, _simd_weight, _out)                                \
  {                                                                          \
    _out.translation = _out.translation - _in.translation * _simd_weight;    \
    /* Interpolate quaternion between identity and src.rotation.*/           \
    /* Quaternion sign is fixed up, so that lerp takes the shortest path.*/  \
    const math::SimdInt4 sign = math::Sign(_in.rotation.w);                  \
    const math::SoaQuaternion rotation = {                                   \
        math::Xor(_in.rotation.x, sign), math::Xor(_in.rotation.y, sign),    \
        math::Xor(_in.rotation.z, sign), math::Xor(_in.rotation.w, sign)};   \
    const math::SoaQuaternion interp_quat = {                                \
        rotation.x * _simd_weight, rotation.y * _simd_weight,                \
        rotation.z * _simd_weight, (rotation.w - one) * _simd_weight + one}; \
    _out.rotation = Conjugate(NormalizeEst(interp_quat)) * _out.rotation;    \
    const math::SoaFloat3 rcp_scale = {                                      \
        math::RcpEst(one_minus_weight + (_in.scale.x * _simd_weight)),       \
        math::RcpEst(one_minus_weight + (_in.scale.y * _simd_weight)),       \
        math::RcpEst(one_minus_weight + (_in.scale.z * _simd_weight))};      \
    _out.scale = _out.scale * rcp_scale;                                     \
  }

// Defines parameters that are passed through blending stages.
struct ProcessArgs {
  ProcessArgs(const BlendingJob& _job)
      : job(_job),
        num_soa_joints(_job.bind_pose.end - _job.bind_pose.begin),
        num_passes(0),
        num_partial_passes(0),
        accumulated_weight(0.f) {
    // The range of all buffers has already been validated.
    assert(job.output.end >= job.output.begin + num_soa_joints);
    assert(OZZ_ARRAY_SIZE(accumulated_weights) >= num_soa_joints);
  }

  // Allocates enough space to store a accumulated weights per-joint.
  // It will be initialized by the first pass processed, if any.
  // This is quite big for a stack allocation (16 byte * maximum number of
  // joints). This is one of the reasons why the number of joints is limited
  // by the API.
  // Note that this array is used with SoA data.
  // This is the first argument in order to avoid wasting too much space with
  // alignment padding.
  math::SimdFloat4 accumulated_weights[Skeleton::kMaxSoAJoints];

  // The job to process.
  const BlendingJob& job;

  // The number of transforms to process as defined by the size of the bind
  // pose.
  size_t num_soa_joints;

  // Number of processed blended passes (excluding passes with a weight <= 0.f),
  // including partial passes.
  int num_passes;

  // Number of processed partial blending passes (aka with a weight per-joint).
  int num_partial_passes;

  // The accumulated weight of all layers.
  float accumulated_weight;

 private:
  // Disables assignment operators.
  ProcessArgs(const ProcessArgs&);
  void operator=(const ProcessArgs&);
};

// Blends all layers of the job to its output.
void BlendLayers(ProcessArgs* _args) {
  assert(_args);

  // Iterates through all layers and blend them to the output.
  for (const BlendingJob::Layer* layer = _args->job.layers.begin;
       layer < _args->job.layers.end; ++layer) {
    // Asserts buffer sizes, which must never fail as it has been validated.
    assert(layer->transform.end >=
           layer->transform.begin + _args->num_soa_joints);
    assert(!layer->joint_weights.begin ||
           (layer->joint_weights.end >=
            layer->joint_weights.begin + _args->num_soa_joints));

    // Skip irrelevant layers.
    if (layer->weight <= 0.f) {
      continue;
    }

    // Accumulates global weights.
    _args->accumulated_weight += layer->weight;
    const math::SimdFloat4 layer_weight =
        math::simd_float4::Load1(layer->weight);

    if (layer->joint_weights.begin) {
      // This layer has per-joint weights.
      ++_args->num_partial_passes;

      if (_args->num_passes == 0) {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform* dest = _args->job.output.begin + i;
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer->joint_weights.begin[i]);
          _args->accumulated_weights[i] = weight;
          OZZ_BLEND_1ST_PASS(src, weight, dest);
        }
      } else {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform* dest = _args->job.output.begin + i;
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer->joint_weights.begin[i]);
          _args->accumulated_weights[i] =
              _args->accumulated_weights[i] + weight;
          OZZ_BLEND_N_PASS(src, weight, dest);
        }
      }
    } else {
      // This is a full layer.
      if (_args->num_passes == 0) {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform* dest = _args->job.output.begin + i;
          _args->accumulated_weights[i] = layer_weight;
          OZZ_BLEND_1ST_PASS(src, layer_weight, dest);
        }
      } else {
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform* dest = _args->job.output.begin + i;
          _args->accumulated_weights[i] =
              _args->accumulated_weights[i] + layer_weight;
          OZZ_BLEND_N_PASS(src, layer_weight, dest);
        }
      }
    }
    // One more pass blended.
    ++_args->num_passes;
  }
}

// Blends bind pose to the output if accumulated weight is less than the
// threshold value.
void BlendBindPose(ProcessArgs* _args) {
  assert(_args);

  // Asserts buffer sizes, which must never fail as it has been validated.
  assert(_args->job.bind_pose.end >=
         _args->job.bind_pose.begin + _args->num_soa_joints);

  if (_args->num_partial_passes == 0) {
    // No partial blending pass detected, threshold can be tested globally.
    const float bp_weight = _args->job.threshold - _args->accumulated_weight;

    if (bp_weight > 0.f) {  // The bind-pose is needed if it has a weight.
      if (_args->num_passes == 0) {
        // Strictly copying bind-pose.
        _args->accumulated_weight = 1.f;
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          _args->job.output.begin[i] = _args->job.bind_pose.begin[i];
        }
      } else {
        // Updates global accumulated weight, but not per-joint weight any more
        // because normalization stage will be global also.
        _args->accumulated_weight = _args->job.threshold;

        const math::SimdFloat4 simd_bp_weight =
            math::simd_float4::Load1(bp_weight);

        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = _args->job.bind_pose.begin[i];
          math::SoaTransform* dest = _args->job.output.begin + i;
          OZZ_BLEND_N_PASS(src, simd_bp_weight, dest);
        }
      }
    }
  } else {
    // Blending passes contain partial blending, threshold must be tested for
    // each joint.
    const math::SimdFloat4 threshold =
        math::simd_float4::Load1(_args->job.threshold);

    // There's been at least 1 pass as num_partial_passes != 0.
    assert(_args->num_passes != 0);

    for (size_t i = 0; i < _args->num_soa_joints; ++i) {
      const math::SoaTransform& src = _args->job.bind_pose.begin[i];
      math::SoaTransform* dest = _args->job.output.begin + i;
      const math::SimdFloat4 bp_weight =
          math::Max0(threshold - _args->accumulated_weights[i]);
      _args->accumulated_weights[i] =
          math::Max(threshold, _args->accumulated_weights[i]);
      OZZ_BLEND_N_PASS(src, bp_weight, dest);
    }
  }
}

// Normalizes output rotations. Quaternion length cannot be zero as opposed
// quaternions have been fixed up during blending passes.
// Translations and scales are already normalized because weights were
// pre-multiplied by the normalization ratio.
void Normalize(ProcessArgs* _args) {
  assert(_args);

  if (_args->num_partial_passes == 0) {
    // Normalization of a non-partial blending requires to apply the same
    // division to all joints.
    const math::SimdFloat4 ratio =
        math::simd_float4::Load1(1.f / _args->accumulated_weight);
    for (size_t i = 0; i < _args->num_soa_joints; ++i) {
      math::SoaTransform& dest = _args->job.output.begin[i];
      dest.rotation = NormalizeEst(dest.rotation);
      dest.translation = dest.translation * ratio;
      dest.scale = dest.scale * ratio;
    }
  } else {
    // Partial blending normalization requires to compute the divider per-joint.
    const math::SimdFloat4 one = math::simd_float4::one();
    for (size_t i = 0; i < _args->num_soa_joints; ++i) {
      const math::SimdFloat4 ratio = one / _args->accumulated_weights[i];
      math::SoaTransform& dest = _args->job.output.begin[i];
      dest.rotation = NormalizeEst(dest.rotation);
      dest.translation = dest.translation * ratio;
      dest.scale = dest.scale * ratio;
    }
  }
}

// Process additive blending pass.
void AddLayers(ProcessArgs* _args) {
  assert(_args);

  // Iterates through all layers and blend them to the output.
  for (const BlendingJob::Layer* layer = _args->job.additive_layers.begin;
       layer < _args->job.additive_layers.end; ++layer) {
    // Asserts buffer sizes, which must never fail as it has been validated.
    assert(layer->transform.end >=
           layer->transform.begin + _args->num_soa_joints);
    assert(!layer->joint_weights.begin ||
           (layer->joint_weights.end >=
            layer->joint_weights.begin + _args->num_soa_joints));

    // Prepares constants.
    const math::SimdFloat4 one = math::simd_float4::one();

    if (layer->weight > 0.f) {
      // Weight is positive, need to perform additive blending.
      const math::SimdFloat4 layer_weight =
          math::simd_float4::Load1(layer->weight);

      if (layer->joint_weights.begin) {
        // This layer has per-joint weights.
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform& dest = _args->job.output.begin[i];
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer->joint_weights.begin[i]);
          const math::SimdFloat4 one_minus_weight = one - weight;
          const math::SoaFloat3 one_minus_weight_f3 = {
              one_minus_weight, one_minus_weight, one_minus_weight};
          OZZ_ADD_PASS(src, weight, dest);
        }
      } else {
        // This is a full layer.
        const math::SimdFloat4 one_minus_weight = one - layer_weight;
        const math::SoaFloat3 one_minus_weight_f3 = {
            one_minus_weight, one_minus_weight, one_minus_weight};

        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform& dest = _args->job.output.begin[i];
          OZZ_ADD_PASS(src, layer_weight, dest);
        }
      }
    } else if (layer->weight < 0.f) {
      // Weight is negative, need to perform subtractive blending.
      const math::SimdFloat4 layer_weight =
          math::simd_float4::Load1(-layer->weight);

      if (layer->joint_weights.begin) {
        // This layer has per-joint weights.
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform& dest = _args->job.output.begin[i];
          const math::SimdFloat4 weight =
              layer_weight * math::Max0(layer->joint_weights.begin[i]);
          const math::SimdFloat4 one_minus_weight = one - weight;
          OZZ_SUB_PASS(src, weight, dest);
        }
      } else {
        // This is a full layer.
        const math::SimdFloat4 one_minus_weight = one - layer_weight;
        for (size_t i = 0; i < _args->num_soa_joints; ++i) {
          const math::SoaTransform& src = layer->transform.begin[i];
          math::SoaTransform& dest = _args->job.output.begin[i];
          OZZ_SUB_PASS(src, layer_weight, dest);
        }
      }
    } else {
      // Skip layer as its weight is 0.
    }
  }
}
}  // namespace

bool BlendingJob::Run() const {
  if (!Validate()) {
    return false;
  }

  // Initializes blended parameters that are exchanged across blend stages.
  ProcessArgs process_args(*this);

  // Blends all layers to the job output buffers.
  BlendLayers(&process_args);

  // Applies bind pose.
  BlendBindPose(&process_args);

  // Normalizes output.
  Normalize(&process_args);

  // Process additive blending.
  AddLayers(&process_args);

  return true;
}
}  // namespace animation
}  // namespace ozz

// Including local_to_model_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/local_to_model_job.h"

#include <cassert>

#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/simd_math.h"
#include "ozz/base/maths/soa_float4x4.h"
#include "ozz/base/maths/soa_transform.h"

#include "ozz/animation/runtime/skeleton.h"

namespace ozz {
namespace animation {

bool LocalToModelJob::Validate() const {
  // Don't need any early out, as jobs are valid in most of the performance
  // critical cases.
  // Tests are written in multiple lines in order to avoid branches.
  bool valid = true;

  // Test for NULL begin pointers.
  if (!skeleton) {
    return false;
  }
  valid &= input.begin != NULL;
  valid &= output.begin != NULL;

  const int num_joints = skeleton->num_joints();
  const int num_soa_joints = (num_joints + 3) / 4;

  // Test input and output ranges, implicitly tests for NULL end pointers.
  valid &= input.end - input.begin >= num_soa_joints;
  valid &= output.end - output.begin >= num_joints;

  return valid;
}

bool LocalToModelJob::Run() const {
  using math::SoaTransform;
  using math::SoaFloat4x4;
  using math::Float4x4;

  if (!Validate()) {
    return false;
  }

  // Early out if no joint.
  const int num_joints = skeleton->num_joints();
  if (num_joints == 0) {
    return true;
  }

  // Fetch joint's properties.
  Range<const Skeleton::JointProperties> properties =
      skeleton->joint_properties();

  // Output.
  Float4x4* const model_matrices = output.begin;

  // Initializes an identity matrix that will be used to compute roots model
  // matrices without requiring a branch.
  const Float4x4 identity = Float4x4::identity();

  // Converts to matrices and applies hierarchical transformation.
  for (int joint = 0; joint < num_joints;) {
    // Builds soa matrices from soa transforms.
    const SoaTransform& transform = input.begin[joint / 4];
    const SoaFloat4x4 local_soa_matrices = SoaFloat4x4::FromAffine(
        transform.translation, transform.rotation, transform.scale);
    // Converts to aos matrices.
    math::SimdFloat4 local_aos_matrices[16];
    math::Transpose16x16(&local_soa_matrices.cols[0].x, local_aos_matrices);

    // Applies hierarchical transformation.
    const int proceed_up_to = joint + math::Min(4, num_joints - joint);
    const math::SimdFloat4* local_aos_matrix = local_aos_matrices;
    for (; joint < proceed_up_to; ++joint, local_aos_matrix += 4) {
      const int parent = properties.begin[joint].parent;
      const Float4x4* parent_matrix =
          math::Select(parent == Skeleton::kNoParentIndex, &identity,
                       &model_matrices[parent]);
      const Float4x4 local_matrix = {{local_aos_matrix[0], local_aos_matrix[1],
                                      local_aos_matrix[2],
                                      local_aos_matrix[3]}};
      model_matrices[joint] = (*parent_matrix) * local_matrix;
    }
  }
  return true;
}
}  // namespace animation
}  // namespace ozz

// Including sampling_job.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/sampling_job.h"

#include <cassert>

#include "ozz/animation/runtime/animation.h"
#include "ozz/base/maths/math_constant.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/soa_transform.h"
#include "ozz/base/memory/allocator.h"

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/runtime/animation_keyframe.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_
#define OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

namespace ozz {
namespace animation {

// Define animation key frame types (translation, rotation, scale). Every type
// as the same base made of the key time and it's track. This is required as
// key frames are not sorted per track, but sorted by time to favor cache
// coherency.
// Key frame values are compressed, according on their type. Decompression is
// efficient because it's done on SoA data and cached during sampling.

// Defines the translation key frame type.
// Translation values are stored as half precision floats with 16 bits per
// component.
struct TranslationKey {
  float time;
  uint16_t track;
  uint16_t value[3];
};

// Defines the rotation key frame type.
// Rotation value is a quaternion. Quaternion are normalized, which means each
// component is in range [0:1]. This property allows to quantize the 3
// components to 3 signed integer 16 bits values. The 4th component is restored
// at runtime, using the knowledge that |w| = sqrt(1 - (a^2 + b^2 + c^2)).
// The sign of this 4th component is stored using 1 bit taken from the track
// member.
//
// In more details, compression algorithm stores the 3 smallest components of
// the quaternion and restores the largest. The 3 smallest can be pre-multiplied
// by sqrt(2) to gain some precision indeed.
//
// Quantization could be reduced to 11-11-10 bits as often used for animation
// key frames, but in this case RotationKey structure would induce 16 bits of
// padding.
struct RotationKey {
  float time;
  uint16_t track : 13;   // The track this key frame belongs to.
  uint16_t largest : 2;  // The largest component of the quaternion.
  uint16_t sign : 1;     // The sign of the largest component. 1 for negative.
  int16_t value[3];      // The quantized value of the 3 smallest components.
};

// Defines the scale key frame type.
// Scale values are stored as half precision floats with 16 bits per
// component.
struct ScaleKey {
  float time;
  uint16_t track;
  uint16_t value[3];
};
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_


namespace ozz {
namespace animation {

namespace internal {
struct InterpSoaTranslation {
  math::SimdFloat4 time[2];
  math::SoaFloat3 value[2];
};
struct InterpSoaRotation {
  math::SimdFloat4 time[2];
  math::SoaQuaternion value[2];
};
struct InterpSoaScale {
  math::SimdFloat4 time[2];
  math::SoaFloat3 value[2];
};
}  // namespace internal

bool SamplingJob::Validate() const {
  // Don't need any early out, as jobs are valid in most of the performance
  // critical cases.
  // Tests are written in multiple lines in order to avoid branches.
  bool valid = true;

  // Test for NULL pointers.
  if (!animation || !cache) {
    return false;
  }
  valid &= output.begin != NULL;

  // Tests output range, implicitly tests output.end != NULL.
  const ptrdiff_t num_soa_tracks = animation->num_soa_tracks();
  valid &= output.end - output.begin >= num_soa_tracks;

  // Tests cache size.
  valid &= cache->max_soa_tracks() >= num_soa_tracks;

  return valid;
}

namespace {
// Loops through the sorted key frames and update cache structure.
template <typename _Key>
void UpdateKeys(float _time, int _num_soa_tracks, ozz::Range<const _Key> _keys,
                int* _cursor, int* _cache, unsigned char* _outdated) {
  assert(_num_soa_tracks >= 1);
  const int num_tracks = _num_soa_tracks * 4;
  assert(_keys.begin + num_tracks * 2 <= _keys.end);

  const _Key* cursor = &_keys.begin[*_cursor];
  if (!*_cursor) {
    // Initializes interpolated entries with the first 2 sets of key frames.
    // The sorting algorithm ensures that the first 2 key frames of a track
    // are consecutive.
    for (int i = 0; i < _num_soa_tracks; ++i) {
      const int in_index0 = i * 4;                   // * soa size
      const int in_index1 = in_index0 + num_tracks;  // 2nd row.
      const int out_index = i * 4 * 2;
      _cache[out_index + 0] = in_index0 + 0;
      _cache[out_index + 1] = in_index1 + 0;
      _cache[out_index + 2] = in_index0 + 1;
      _cache[out_index + 3] = in_index1 + 1;
      _cache[out_index + 4] = in_index0 + 2;
      _cache[out_index + 5] = in_index1 + 2;
      _cache[out_index + 6] = in_index0 + 3;
      _cache[out_index + 7] = in_index1 + 3;
    }
    cursor = _keys.begin + num_tracks * 2;  // New cursor position.

    // All entries are outdated. It cares to only flag valid soa entries as
    // this is the exit condition of other algorithms.
    const int num_outdated_flags = (_num_soa_tracks + 7) / 8;
    for (int i = 0; i < num_outdated_flags - 1; ++i) {
      _outdated[i] = 0xff;
    }
    _outdated[num_outdated_flags - 1] =
        0xff >> (num_outdated_flags * 8 - _num_soa_tracks);
  } else {
    assert(cursor >= _keys.begin + num_tracks * 2 && cursor <= _keys.end);
  }

  // Search for the keys that matches _time.
  // Iterates while the cache is not updated with left and right keys required
  // for interpolation at time _time, for all tracks. Thanks to the keyframe
  // sorting, the loop can end as soon as it finds a key greater that _time.
  // It will mean that all the keys lower than _time have been processed,
  // meaning all cache entries are updated.
  while (cursor < _keys.end &&
         _keys.begin[_cache[cursor->track * 2 + 1]].time <= _time) {
    // Flag this soa entry as outdated.
    _outdated[cursor->track / 32] |= (1 << ((cursor->track & 0x1f) / 4));
    // Updates cache.
    const int base = cursor->track * 2;
    _cache[base] = _cache[base + 1];
    _cache[base + 1] = static_cast<int>(cursor - _keys.begin);
    // Process next key.
    ++cursor;
  }
  assert(cursor <= _keys.end);

  // Updates cursor output.
  *_cursor = static_cast<int>(cursor - _keys.begin);
}

void UpdateSoaTranslations(int _num_soa_tracks,
                           ozz::Range<const TranslationKey> _keys,
                           const int* _interp, unsigned char* _outdated,
                           internal::InterpSoaTranslation* soa_translations_) {
  const int num_outdated_flags = (_num_soa_tracks + 7) / 8;
  for (int j = 0; j < num_outdated_flags; ++j) {
    unsigned char outdated = _outdated[j];
    _outdated[j] = 0;  // Reset outdated entries as all will be processed.
    for (int i = j * 8; outdated; ++i, outdated >>= 1) {
      if (!(outdated & 1)) {
        continue;
      }
      const int base = i * 4 * 2;  // * soa size * 2 keys

      // Decompress left side keyframes and store them in soa structures.
      const TranslationKey& k00 = _keys.begin[_interp[base + 0]];
      const TranslationKey& k10 = _keys.begin[_interp[base + 2]];
      const TranslationKey& k20 = _keys.begin[_interp[base + 4]];
      const TranslationKey& k30 = _keys.begin[_interp[base + 6]];
      soa_translations_[i].time[0] =
          math::simd_float4::Load(k00.time, k10.time, k20.time, k30.time);
      soa_translations_[i].value[0].x = math::HalfToFloat(math::simd_int4::Load(
          k00.value[0], k10.value[0], k20.value[0], k30.value[0]));
      soa_translations_[i].value[0].y = math::HalfToFloat(math::simd_int4::Load(
          k00.value[1], k10.value[1], k20.value[1], k30.value[1]));
      soa_translations_[i].value[0].z = math::HalfToFloat(math::simd_int4::Load(
          k00.value[2], k10.value[2], k20.value[2], k30.value[2]));

      // Decompress right side keyframes and store them in soa structures.
      const TranslationKey& k01 = _keys.begin[_interp[base + 1]];
      const TranslationKey& k11 = _keys.begin[_interp[base + 3]];
      const TranslationKey& k21 = _keys.begin[_interp[base + 5]];
      const TranslationKey& k31 = _keys.begin[_interp[base + 7]];
      soa_translations_[i].time[1] =
          math::simd_float4::Load(k01.time, k11.time, k21.time, k31.time);
      soa_translations_[i].value[1].x = math::HalfToFloat(math::simd_int4::Load(
          k01.value[0], k11.value[0], k21.value[0], k31.value[0]));
      soa_translations_[i].value[1].y = math::HalfToFloat(math::simd_int4::Load(
          k01.value[1], k11.value[1], k21.value[1], k31.value[1]));
      soa_translations_[i].value[1].z = math::HalfToFloat(math::simd_int4::Load(
          k01.value[2], k11.value[2], k21.value[2], k31.value[2]));
    }
  }
}

#define DECOMPRESS_SOA_QUAT(_k0, _k1, _k2, _k3, _quat)                         \
  {                                                                            \
    /* Selects proper mapping for each key.*/                                  \
    const int* m0 = kCpntMapping[_k0.largest];                                 \
    const int* m1 = kCpntMapping[_k1.largest];                                 \
    const int* m2 = kCpntMapping[_k2.largest];                                 \
    const int* m3 = kCpntMapping[_k3.largest];                                 \
                                                                               \
    /* Prepares an array of input values, according to the mapping required */ \
    /* to restore quaternion largest component.*/                              \
    OZZ_ALIGN(16)                                                              \
    int cmp_keys[4][4] = {                                                     \
        {_k0.value[m0[0]], _k1.value[m1[0]], _k2.value[m2[0]],                 \
         _k3.value[m3[0]]},                                                    \
        {_k0.value[m0[1]], _k1.value[m1[1]], _k2.value[m2[1]],                 \
         _k3.value[m3[1]]},                                                    \
        {_k0.value[m0[2]], _k1.value[m1[2]], _k2.value[m2[2]],                 \
         _k3.value[m3[2]]},                                                    \
        {_k0.value[m0[3]], _k1.value[m1[3]], _k2.value[m2[3]],                 \
         _k3.value[m3[3]]},                                                    \
    };                                                                         \
                                                                               \
    /* Resets largest component to 0.*/                                        \
    cmp_keys[_k0.largest][0] = 0;                                              \
    cmp_keys[_k1.largest][1] = 0;                                              \
    cmp_keys[_k2.largest][2] = 0;                                              \
    cmp_keys[_k3.largest][3] = 0;                                              \
                                                                               \
    /* Rebuilds quaternion from quantized values.*/                            \
    math::SimdFloat4 cpnt[4] = {                                               \
        kInt2Float *                                                           \
            math::simd_float4::FromInt(math::simd_int4::LoadPtr(cmp_keys[0])), \
        kInt2Float *                                                           \
            math::simd_float4::FromInt(math::simd_int4::LoadPtr(cmp_keys[1])), \
        kInt2Float *                                                           \
            math::simd_float4::FromInt(math::simd_int4::LoadPtr(cmp_keys[2])), \
        kInt2Float *                                                           \
            math::simd_float4::FromInt(math::simd_int4::LoadPtr(cmp_keys[3])), \
    };                                                                         \
                                                                               \
    /* Get back length of 4th component. Favors performance over accuracy by*/ \
    /* using x * RSqrtEst(x) instead of Sqrt(x).*/                             \
    const math::SimdFloat4 dot = cpnt[0] * cpnt[0] + cpnt[1] * cpnt[1] +       \
                                 cpnt[2] * cpnt[2] + cpnt[3] * cpnt[3];        \
    const math::SimdFloat4 ww0 = math::Max(eps, one - dot);                    \
    const math::SimdFloat4 w0 = ww0 * math::RSqrtEst(ww0);                     \
    /* Re-applies 4th component's sign.*/                                      \
    const math::SimdInt4 sign = math::ShiftL(                                  \
        math::simd_int4::Load(_k0.sign, _k1.sign, _k2.sign, _k3.sign), 31);    \
    const math::SimdFloat4 restored = math::Or(w0, sign);                      \
                                                                               \
    /* Re-injects the largest component inside the SoA structure.*/            \
    cpnt[_k0.largest] =                                                        \
        math::Or(cpnt[_k0.largest], math::And(restored, mf000));               \
    cpnt[_k1.largest] =                                                        \
        math::Or(cpnt[_k1.largest], math::And(restored, m0f00));               \
    cpnt[_k2.largest] =                                                        \
        math::Or(cpnt[_k2.largest], math::And(restored, m00f0));               \
    cpnt[_k3.largest] =                                                        \
        math::Or(cpnt[_k3.largest], math::And(restored, m000f));               \
                                                                               \
    /* Stores result.*/                                                        \
    _quat.x = cpnt[0];                                                         \
    _quat.y = cpnt[1];                                                         \
    _quat.z = cpnt[2];                                                         \
    _quat.w = cpnt[3];                                                         \
  }

void UpdateSoaRotations(int _num_soa_tracks,
                        ozz::Range<const RotationKey> _keys, const int* _interp,
                        unsigned char* _outdated,
                        internal::InterpSoaRotation* _soa_rotations) {
  // Prepares constants.
  const math::SimdFloat4 one = math::simd_float4::one();
  const math::SimdFloat4 eps = math::simd_float4::Load1(1e-16f);
  const math::SimdFloat4 kInt2Float =
      math::simd_float4::Load1(1.f / (32767.f * math::kSqrt2));
  const math::SimdInt4 mf000 = math::simd_int4::mask_f000();
  const math::SimdInt4 m0f00 = math::simd_int4::mask_0f00();
  const math::SimdInt4 m00f0 = math::simd_int4::mask_00f0();
  const math::SimdInt4 m000f = math::simd_int4::mask_000f();

  // Defines a mapping table that defines components assignation in the output
  // quaternion.
  const int kCpntMapping[4][4] = {
      {0, 0, 1, 2}, {0, 0, 1, 2}, {0, 1, 0, 2}, {0, 1, 2, 0}};

  const int num_outdated_flags = (_num_soa_tracks + 7) / 8;
  for (int j = 0; j < num_outdated_flags; ++j) {
    unsigned char outdated = _outdated[j];
    _outdated[j] = 0;  // Reset outdated entries as all will be processed.
    for (int i = j * 8; outdated; ++i, outdated >>= 1) {
      if (!(outdated & 1)) {
        continue;
      }

      const int base = i * 4 * 2;  // * soa size * 2 keys per track

      // Decompress left side keyframes and store them in soa structures.
      {
        const RotationKey& k0 = _keys.begin[_interp[base + 0]];
        const RotationKey& k1 = _keys.begin[_interp[base + 2]];
        const RotationKey& k2 = _keys.begin[_interp[base + 4]];
        const RotationKey& k3 = _keys.begin[_interp[base + 6]];

        _soa_rotations[i].time[0] =
            math::simd_float4::Load(k0.time, k1.time, k2.time, k3.time);
        math::SoaQuaternion& quat = _soa_rotations[i].value[0];
        DECOMPRESS_SOA_QUAT(k0, k1, k2, k3, quat);
      }

      // Decompress right side keyframes and store them in soa structures.
      {
        const RotationKey& k0 = _keys.begin[_interp[base + 1]];
        const RotationKey& k1 = _keys.begin[_interp[base + 3]];
        const RotationKey& k2 = _keys.begin[_interp[base + 5]];
        const RotationKey& k3 = _keys.begin[_interp[base + 7]];

        _soa_rotations[i].time[1] =
            math::simd_float4::Load(k0.time, k1.time, k2.time, k3.time);
        math::SoaQuaternion& quat = _soa_rotations[i].value[1];
        DECOMPRESS_SOA_QUAT(k0, k1, k2, k3, quat);
      }
    }
  }
}

#undef DECOMPRESS_SOA_QUAT

void UpdateSoaScales(int _num_soa_tracks, ozz::Range<const ScaleKey> _keys,
                     const int* _interp, unsigned char* _outdated,
                     internal::InterpSoaScale* soa_scales_) {
  const int num_outdated_flags = (_num_soa_tracks + 7) / 8;
  for (int j = 0; j < num_outdated_flags; ++j) {
    unsigned char outdated = _outdated[j];
    _outdated[j] = 0;  // Reset outdated entries as all will be processed.
    for (int i = j * 8; outdated; ++i, outdated >>= 1) {
      if (!(outdated & 1)) {
        continue;
      }
      const int base = i * 4 * 2;  // * soa size * 2 keys

      // Decompress left side keyframes and store them in soa structures.
      const ScaleKey& k00 = _keys.begin[_interp[base + 0]];
      const ScaleKey& k10 = _keys.begin[_interp[base + 2]];
      const ScaleKey& k20 = _keys.begin[_interp[base + 4]];
      const ScaleKey& k30 = _keys.begin[_interp[base + 6]];
      soa_scales_[i].time[0] =
          math::simd_float4::Load(k00.time, k10.time, k20.time, k30.time);
      soa_scales_[i].value[0].x = math::HalfToFloat(math::simd_int4::Load(
          k00.value[0], k10.value[0], k20.value[0], k30.value[0]));
      soa_scales_[i].value[0].y = math::HalfToFloat(math::simd_int4::Load(
          k00.value[1], k10.value[1], k20.value[1], k30.value[1]));
      soa_scales_[i].value[0].z = math::HalfToFloat(math::simd_int4::Load(
          k00.value[2], k10.value[2], k20.value[2], k30.value[2]));

      // Decompress right side keyframes and store them in soa structures.
      const ScaleKey& k01 = _keys.begin[_interp[base + 1]];
      const ScaleKey& k11 = _keys.begin[_interp[base + 3]];
      const ScaleKey& k21 = _keys.begin[_interp[base + 5]];
      const ScaleKey& k31 = _keys.begin[_interp[base + 7]];
      soa_scales_[i].time[1] =
          math::simd_float4::Load(k01.time, k11.time, k21.time, k31.time);
      soa_scales_[i].value[1].x = math::HalfToFloat(math::simd_int4::Load(
          k01.value[0], k11.value[0], k21.value[0], k31.value[0]));
      soa_scales_[i].value[1].y = math::HalfToFloat(math::simd_int4::Load(
          k01.value[1], k11.value[1], k21.value[1], k31.value[1]));
      soa_scales_[i].value[1].z = math::HalfToFloat(math::simd_int4::Load(
          k01.value[2], k11.value[2], k21.value[2], k31.value[2]));
    }
  }
}

void Interpolates(float _anim_time, int _num_soa_tracks,
                  const internal::InterpSoaTranslation* _translations,
                  const internal::InterpSoaRotation* _rotations,
                  const internal::InterpSoaScale* _scales,
                  math::SoaTransform* _output) {
  const math::SimdFloat4 anim_time = math::simd_float4::Load1(_anim_time);
  for (int i = 0; i < _num_soa_tracks; ++i) {
    // Prepares interpolation coefficients.
    const math::SimdFloat4 interp_t_time =
        (anim_time - _translations[i].time[0]) *
        math::RcpEst(_translations[i].time[1] - _translations[i].time[0]);
    const math::SimdFloat4 interp_r_time =
        (anim_time - _rotations[i].time[0]) *
        math::RcpEst(_rotations[i].time[1] - _rotations[i].time[0]);
    const math::SimdFloat4 interp_s_time =
        (anim_time - _scales[i].time[0]) *
        math::RcpEst(_scales[i].time[1] - _scales[i].time[0]);

    // Processes interpolations.
    // The lerp of the rotation uses the shortest path, because opposed
    // quaternions were negated during animation build stage (AnimationBuilder).
    _output[i].translation = Lerp(_translations[i].value[0],
                                  _translations[i].value[1], interp_t_time);
    _output[i].rotation =
        NLerpEst(_rotations[i].value[0], _rotations[i].value[1], interp_r_time);
    _output[i].scale =
        Lerp(_scales[i].value[0], _scales[i].value[1], interp_s_time);
  }
}
}  // namespace

SamplingJob::SamplingJob() : time(0.f), animation(NULL), cache(NULL) {}

bool SamplingJob::Run() const {
  if (!Validate()) {
    return false;
  }

  const int num_soa_tracks = animation->num_soa_tracks();
  if (num_soa_tracks == 0) {  // Early out if animation contains no joint.
    return true;
  }

  // Clamps time in range [0,duration].
  const float anim_time = math::Clamp(0.f, time, animation->duration());

  // Step the cache to this potentially new animation and time.
  assert(cache->max_soa_tracks() >= num_soa_tracks);
  cache->Step(*animation, anim_time);

  // Fetch key frames from the animation to the cache a t = anim_time.
  // Then updates outdated soa hot values.
  UpdateKeys(anim_time, num_soa_tracks, animation->translations(),
             &cache->translation_cursor_, cache->translation_keys_,
             cache->outdated_translations_);
  UpdateSoaTranslations(num_soa_tracks, animation->translations(),
                        cache->translation_keys_, cache->outdated_translations_,
                        cache->soa_translations_);

  UpdateKeys(anim_time, num_soa_tracks, animation->rotations(),
             &cache->rotation_cursor_, cache->rotation_keys_,
             cache->outdated_rotations_);
  UpdateSoaRotations(num_soa_tracks, animation->rotations(),
                     cache->rotation_keys_, cache->outdated_rotations_,
                     cache->soa_rotations_);

  UpdateKeys(anim_time, num_soa_tracks, animation->scales(),
             &cache->scale_cursor_, cache->scale_keys_,
             cache->outdated_scales_);
  UpdateSoaScales(num_soa_tracks, animation->scales(), cache->scale_keys_,
                  cache->outdated_scales_, cache->soa_scales_);

  // Interpolates soa hot data.
  Interpolates(anim_time, num_soa_tracks, cache->soa_translations_,
               cache->soa_rotations_, cache->soa_scales_, output.begin);

  return true;
}

SamplingCache::SamplingCache(int _max_tracks)
    : animation_(NULL),
      time_(0.f),
      max_soa_tracks_((_max_tracks + 3) / 4),
      soa_translations_(NULL),
      soa_rotations_(NULL),
      soa_scales_(NULL),
      translation_keys_(NULL),
      rotation_keys_(NULL),
      scale_keys_(NULL),
      translation_cursor_(0),
      rotation_cursor_(0),
      scale_cursor_(0),
      outdated_translations_(NULL),
      outdated_rotations_(NULL),
      outdated_scales_(NULL) {
  using internal::InterpSoaTranslation;
  using internal::InterpSoaRotation;
  using internal::InterpSoaScale;

  // Allocate all cache data at once in a single allocation.
  // Alignment is guaranteed because memory is dispatch from the highest
  // alignment requirement (Soa data: SimdFloat4) to the lowest (outdated
  // flag: unsigned char).

  // Computes allocation size.
  const size_t max_tracks = max_soa_tracks_ * 4;
  const size_t num_outdated = (max_soa_tracks_ + 7) / 8;
  const size_t size =
      sizeof(InterpSoaTranslation) * max_soa_tracks_ +
      sizeof(InterpSoaRotation) * max_soa_tracks_ +
      sizeof(InterpSoaScale) * max_soa_tracks_ +
      sizeof(int) * max_tracks * 2 * 3 +  // 2 keys * (trans + rot + scale).
      sizeof(unsigned char) * 3 * num_outdated;

  // Allocates all at once.
  memory::Allocator* allocator = memory::default_allocator();
  char* alloc_begin = reinterpret_cast<char*>(
      allocator->Allocate(size, OZZ_ALIGN_OF(InterpSoaTranslation)));
  char* alloc_cursor = alloc_begin;

  // Dispatches allocated memory, from the highest alignment requirement to the
  // lowest.
  soa_translations_ = reinterpret_cast<InterpSoaTranslation*>(alloc_cursor);
  alloc_cursor += sizeof(InterpSoaTranslation) * max_soa_tracks_;
  soa_rotations_ = reinterpret_cast<InterpSoaRotation*>(alloc_cursor);
  alloc_cursor += sizeof(InterpSoaRotation) * max_soa_tracks_;
  soa_scales_ = reinterpret_cast<InterpSoaScale*>(alloc_cursor);
  alloc_cursor += sizeof(InterpSoaScale) * max_soa_tracks_;

  translation_keys_ = reinterpret_cast<int*>(alloc_cursor);
  alloc_cursor += sizeof(int) * max_tracks * 2;
  rotation_keys_ = reinterpret_cast<int*>(alloc_cursor);
  alloc_cursor += sizeof(int) * max_tracks * 2;
  scale_keys_ = reinterpret_cast<int*>(alloc_cursor);
  alloc_cursor += sizeof(int) * max_tracks * 2;

  outdated_translations_ = reinterpret_cast<unsigned char*>(alloc_cursor);
  alloc_cursor += sizeof(unsigned char) * num_outdated;
  outdated_rotations_ = reinterpret_cast<unsigned char*>(alloc_cursor);
  alloc_cursor += sizeof(unsigned char) * num_outdated;
  outdated_scales_ = reinterpret_cast<unsigned char*>(alloc_cursor);
  alloc_cursor += sizeof(unsigned char) * num_outdated;

  assert(alloc_cursor == alloc_begin + size);
}

SamplingCache::~SamplingCache() {
  // Deallocates everything at once.
  memory::default_allocator()->Deallocate(soa_translations_);
}

void SamplingCache::Step(const Animation& _animation, float _time) {
  // The cache is invalidated if animation has changed or if it is being rewind.
  if (animation_ != &_animation || _time < time_) {
    animation_ = &_animation;
    translation_cursor_ = 0;
    rotation_cursor_ = 0;
    scale_cursor_ = 0;
  }
  time_ = _time;
}

void SamplingCache::Invalidate() {
  animation_ = NULL;
  time_ = 0.f;
  translation_cursor_ = 0;
  rotation_cursor_ = 0;
  scale_cursor_ = 0;
}
}  // namespace animation
}  // namespace ozz

// Including skeleton.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/skeleton.h"

#include <cstring>

#include "ozz/base/io/archive.h"
#include "ozz/base/log.h"
#include "ozz/base/maths/math_ex.h"
#include "ozz/base/maths/soa_math_archive.h"
#include "ozz/base/maths/soa_transform.h"
#include "ozz/base/memory/allocator.h"

namespace ozz {
namespace io {
// JointProperties' version can be declared locally as it will be saved from
// this
// cpp file only.
OZZ_IO_TYPE_VERSION(1, animation::Skeleton::JointProperties)

// Specializes Skeleton::JointProperties. This structure's bitset isn't written
// as-is because of endianness issues.
template <>
void Save(OArchive& _archive,
          const animation::Skeleton::JointProperties* _properties,
          size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    uint16_t parent = _properties[i].parent;
    _archive << parent;
    bool is_leaf = _properties[i].is_leaf != 0;
    _archive << is_leaf;
  }
}

template <>
void Load(IArchive& _archive, animation::Skeleton::JointProperties* _properties,
          size_t _count, uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    uint16_t parent;
    _archive >> parent;
    _properties[i].parent = parent;
    bool is_leaf;
    _archive >> is_leaf;
    _properties[i].is_leaf = is_leaf;
  }
}
}  // namespace io

namespace animation {

Skeleton::Skeleton() {}

Skeleton::~Skeleton() { Deallocate(); }

char* Skeleton::Allocate(size_t _chars_size, size_t _num_joints) {
  // Distributes buffer memory while ensuring proper alignment (serves larger
  // alignment values first).
  OZZ_STATIC_ASSERT(
      OZZ_ALIGN_OF(math::SoaTransform) >= OZZ_ALIGN_OF(char*) &&
      OZZ_ALIGN_OF(char*) >= OZZ_ALIGN_OF(Skeleton::JointProperties) &&
      OZZ_ALIGN_OF(Skeleton::JointProperties) >= OZZ_ALIGN_OF(char));

  assert(bind_pose_.Size() == 0 && joint_names_.Size() == 0 &&
         joint_properties_.Size() == 0);

  // Early out if no joint.
  if (_num_joints == 0) {
    return NULL;
  }

  // Bind poses have SoA format
  const size_t bind_poses_size =
      (_num_joints + 3) / 4 * sizeof(math::SoaTransform);
  const size_t names_size = _num_joints * sizeof(char*);
  const size_t properties_size =
      _num_joints * sizeof(Skeleton::JointProperties);
  const size_t buffer_size =
      names_size + _chars_size + properties_size + bind_poses_size;

  // Allocates whole buffer.
  char* buffer = reinterpret_cast<char*>(memory::default_allocator()->Allocate(
      buffer_size, OZZ_ALIGN_OF(math::SoaTransform)));

  // Bind pose first, biggest alignment.
  bind_pose_.begin = reinterpret_cast<math::SoaTransform*>(buffer);
  assert(math::IsAligned(bind_pose_.begin, OZZ_ALIGN_OF(math::SoaTransform)));
  buffer += bind_poses_size;
  bind_pose_.end = reinterpret_cast<math::SoaTransform*>(buffer);

  // Then names array, second biggest alignment.
  joint_names_.begin = reinterpret_cast<char**>(buffer);
  assert(math::IsAligned(joint_names_.begin, OZZ_ALIGN_OF(char**)));
  buffer += names_size;
  joint_names_.end = reinterpret_cast<char**>(buffer);

  // Properties, third biggest alignment.
  joint_properties_.begin =
      reinterpret_cast<Skeleton::JointProperties*>(buffer);
  assert(math::IsAligned(joint_properties_.begin,
                         OZZ_ALIGN_OF(Skeleton::JointProperties)));
  buffer += properties_size;
  joint_properties_.end = reinterpret_cast<Skeleton::JointProperties*>(buffer);

  // Remaning buffer will be used to store joint names.
  return buffer;
}

void Skeleton::Deallocate() {
  memory::default_allocator()->Deallocate(bind_pose_.begin);
  bind_pose_.Clear();
  joint_names_.Clear();
  joint_properties_.Clear();
}

void Skeleton::Save(ozz::io::OArchive& _archive) const {
  const int32_t num_joints = this->num_joints();

  // Early out if skeleton's empty.
  _archive << num_joints;
  if (!num_joints) {
    return;
  }

  // Stores names. They are all concatenated in the same buffer, starting at
  // joint_names_[0].
  size_t chars_count = 0;
  for (int i = 0; i < num_joints; ++i) {
    chars_count += (std::strlen(joint_names_[i]) + 1) * sizeof(char);
  }
  _archive << static_cast<int32_t>(chars_count);
  _archive << ozz::io::MakeArray(joint_names_[0], chars_count);

  // Stores joint's properties.
  _archive << ozz::io::MakeArray(joint_properties_);

  // Stores bind poses.
  _archive << ozz::io::MakeArray(bind_pose_);
}

void Skeleton::Load(ozz::io::IArchive& _archive, uint32_t _version) {
  // Deallocate skeleton in case it was already used before.
  Deallocate();

  if (_version != 1) {
    log::Err() << "Unsupported Skeleton version " << _version << "."
               << std::endl;
    return;
  }

  int32_t num_joints;
  _archive >> num_joints;

  // Early out if skeleton's empty.
  if (!num_joints) {
    return;
  }

  // Read names.
  int32_t chars_count;
  _archive >> chars_count;

  // Allocates all skeleton data members.
  char* cursor = Allocate(chars_count, num_joints);

  // Reads name's buffer, they are all contiguous in the same buffer.
  _archive >> ozz::io::MakeArray(cursor, chars_count);

  // Fixes up array of pointers. Stops at num_joints - 1, so that it doesn't
  // read memory past the end of the buffer.
  for (int i = 0; i < num_joints - 1; ++i) {
    joint_names_[i] = cursor;
    cursor += std::strlen(joint_names_[i]) + 1;
  }
  // num_joints is > 0, as this was tested at the beginning of the function.
  joint_names_[num_joints - 1] = cursor;

  _archive >> ozz::io::MakeArray(joint_properties_);
  _archive >> ozz::io::MakeArray(bind_pose_);
}
}  // namespace animation
}  // namespace ozz

// Including skeleton_utils.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/runtime/skeleton_utils.h"

#include "ozz/base/maths/soa_transform.h"

#include <assert.h>

namespace ozz {
namespace animation {

// Unpacks skeleton bind pose stored in soa format by the skeleton.
ozz::math::Transform GetJointLocalBindPose(const Skeleton& _skeleton,
                                           int _joint) {
  assert(_joint >= 0 && _joint < _skeleton.num_joints() &&
         "Joint index out of range.");

  const ozz::math::SoaTransform& soa_transform =
      _skeleton.bind_pose()[_joint / 4];

  // Transpose SoA data to AoS.
  ozz::math::SimdFloat4 translations[4];
  ozz::math::Transpose3x4(&soa_transform.translation.x, translations);
  ozz::math::SimdFloat4 rotations[4];
  ozz::math::Transpose4x4(&soa_transform.rotation.x, rotations);
  ozz::math::SimdFloat4 scales[4];
  ozz::math::Transpose3x4(&soa_transform.scale.x, scales);

  // Stores to the Transform object.
  math::Transform bind_pose;
  const int offset = _joint % 4;
  ozz::math::Store3PtrU(translations[offset], &bind_pose.translation.x);
  ozz::math::StorePtrU(rotations[offset], &bind_pose.rotation.x);
  ozz::math::Store3PtrU(scales[offset], &bind_pose.scale.x);

  return bind_pose;
}

// Helper macro used to detect if a joint has a brother.
#define _HAS_SIBLING(_i, _num_joints, _properties) \
  ((_i + 1 < _num_joints) &&                       \
   (_properties[_i].parent == _properties[_i + 1].parent))

// Implement joint hierarchy depth-first traversal.
// Uses a non-recursive implementation to control stack usage (ie: making
// algorithm behavior (stack consumption) independent off the data being
// processed).
void IterateJointsDF(const Skeleton& _skeleton, int _from,
                     JointsIterator* _iterator) {
  assert(_iterator);
  const int num_joints = _skeleton.num_joints();
  Range<const Skeleton::JointProperties> properties =
      _skeleton.joint_properties();

  // Initialize iterator.
  _iterator->num_joints = 0;

  // Validates input range first.
  if (num_joints == 0) {
    return;
  }
  if ((_from < 0 || _from >= num_joints) && _from != Skeleton::kNoParentIndex) {
    return;
  }

  // Simulate a stack to unroll usual recursive implementation.
  struct Context {
    uint16_t joint : 15;
    uint16_t has_brother : 1;
  };
  Context stack[Skeleton::kMaxJoints];
  int stack_size = 0;

  // Initializes iteration start.
  Context start;
  if (_from != Skeleton::kNoParentIndex) {
    start.joint = _from;
    start.has_brother = false;  // Disallow brother processing.
  } else {  // num_joints > 0, which was tested as pre-conditions.
    start.joint = 0;
    start.has_brother = _HAS_SIBLING(0, num_joints, properties.begin);
  }
  stack[stack_size++] = start;

  for (; stack_size != 0;) {
    // Process next joint on the stack.
    const Context& top = stack[stack_size - 1];

    // Push that joint to the list and then process its child.
    _iterator->joints[_iterator->num_joints++] = top.joint;

    // Skip all the joints until the first child is found.
    if (!properties.begin[top.joint].is_leaf) {  // A leaf has no child anyway.
      uint16_t next_joint = top.joint + 1;
      for (; next_joint < num_joints &&
             top.joint != properties.begin[next_joint].parent;
           ++next_joint) {
      }
      if (next_joint < num_joints) {
        Context& next = stack[stack_size++];  // Push child and process it.
        next.joint = next_joint;
        next.has_brother =
            _HAS_SIBLING(next_joint, num_joints, properties.begin);
        continue;
      }
    }

    // Rewind the stack while there's no brother to process.
    for (; stack_size != 0 && !stack[stack_size - 1].has_brother;
         --stack_size) {
    }

    // Replace top joint by its brother.
    if (stack_size != 0) {
      Context& next = stack[stack_size - 1];
      assert(next.has_brother && next.joint + 1 < num_joints);

      ++next.joint;  // The brother is the next joint in breadth-first order.
      next.has_brother = _HAS_SIBLING(next.joint, num_joints, properties.begin);
    }
  }
}
#undef _HAS_SIBLING
}  // namespace animation
}  // namespace ozz

