// This file is autogenerated. Do not modify it.

// Including raw_animation.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_animation.h"
#include "ozz/animation/runtime/skeleton.h"

namespace ozz {
namespace animation {
namespace offline {

RawAnimation::RawAnimation() : duration(1.f) {}

RawAnimation::~RawAnimation() {}

namespace {

// Implements key frames' time range and ordering checks.
// See AnimationBuilder::Create for more details.
template <typename _Key>
static bool ValidateTrack(const typename ozz::Vector<_Key>::Std& _track,
                          float _duration) {
  float previous_time = -1.f;
  for (size_t k = 0; k < _track.size(); ++k) {
    const float frame_time = _track[k].time;
    // Tests frame's time is in range [0:duration].
    if (frame_time < 0.f || frame_time > _duration) {
      return false;
    }
    // Tests that frames are sorted.
    if (frame_time <= previous_time) {
      return false;
    }
    previous_time = frame_time;
  }
  return true;  // Validated.
}
}  // namespace

bool RawAnimation::Validate() const {
  if (duration <= 0.f) {  // Tests duration is valid.
    return false;
  }
  if (tracks.size() > Skeleton::kMaxJoints) {  // Tests number of tracks.
    return false;
  }
  // Ensures that all key frames' time are valid, ie: in a strict ascending
  // order and within range [0:duration].
  for (size_t j = 0; j < tracks.size(); ++j) {
    const RawAnimation::JointTrack& track = tracks[j];
    if (!ValidateTrack<TranslationKey>(track.translations, duration) ||
        !ValidateTrack<RotationKey>(track.rotations, duration) ||
        !ValidateTrack<ScaleKey>(track.scales, duration)) {
      return false;
    }
  }

  return true;  // *this is valid.
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including raw_animation_archive.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_animation.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/maths/math_archive.h"

#include "ozz/base/containers/string_archive.h"
#include "ozz/base/containers/vector_archive.h"

namespace ozz {
namespace io {

template <>
void Save(OArchive& _archive,
          const animation::offline::RawAnimation* _animations, size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawAnimation& animation = _animations[i];
    _archive << animation.duration;
    _archive << animation.tracks;
    _archive << animation.name;
  }
}

template <>
void Load(IArchive& _archive, animation::offline::RawAnimation* _animations,
          size_t _count, uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawAnimation& animation = _animations[i];
    _archive >> animation.duration;
    _archive >> animation.tracks;
    if (_version > 1) {
      _archive >> animation.name;
    }
  }
}

// RawAnimation::*Keys' version can be declared locally as it will be saved from
// this cpp file only.

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::JointTrack)

template <>
void Save(OArchive& _archive,
          const animation::offline::RawAnimation::JointTrack* _tracks,
          size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawAnimation::JointTrack& track = _tracks[i];
    _archive << track.translations;
    _archive << track.rotations;
    _archive << track.scales;
  }
}

template <>
void Load(IArchive& _archive,
          animation::offline::RawAnimation::JointTrack* _tracks, size_t _count,
          uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawAnimation::JointTrack& track = _tracks[i];
    _archive >> track.translations;
    _archive >> track.rotations;
    _archive >> track.scales;
  }
}

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::TranslationKey)

template <>
void Save(OArchive& _archive,
          const animation::offline::RawAnimation::TranslationKey* _keys,
          size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawAnimation::TranslationKey& key = _keys[i];
    _archive << key.time;
    _archive << key.value;
  }
}

template <>
void Load(IArchive& _archive,
          animation::offline::RawAnimation::TranslationKey* _keys,
          size_t _count, uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawAnimation::TranslationKey& key = _keys[i];
    _archive >> key.time;
    _archive >> key.value;
  }
}

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::RotationKey)

template <>
void Save(OArchive& _archive,
          const animation::offline::RawAnimation::RotationKey* _keys,
          size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawAnimation::RotationKey& key = _keys[i];
    _archive << key.time;
    _archive << key.value;
  }
}

template <>
void Load(IArchive& _archive,
          animation::offline::RawAnimation::RotationKey* _keys, size_t _count,
          uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawAnimation::RotationKey& key = _keys[i];
    _archive >> key.time;
    _archive >> key.value;
  }
}

OZZ_IO_TYPE_VERSION(1, animation::offline::RawAnimation::ScaleKey)

template <>
void Save(OArchive& _archive,
          const animation::offline::RawAnimation::ScaleKey* _keys,
          size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawAnimation::ScaleKey& key = _keys[i];
    _archive << key.time;
    _archive << key.value;
  }
}

template <>
void Load(IArchive& _archive, animation::offline::RawAnimation::ScaleKey* _keys,
          size_t _count, uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawAnimation::ScaleKey& key = _keys[i];
    _archive >> key.time;
    _archive >> key.value;
  }
}
}  // namespace io
}  // namespace ozz

// Including raw_animation_utils.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_animation_utils.h"

namespace ozz {
namespace animation {
namespace offline {

// Translation interpolation method.
// This must be the same Lerp as the one used by the sampling job.
math::Float3 LerpTranslation(const math::Float3& _a, const math::Float3& _b,
                             float _alpha) {
  return math::Lerp(_a, _b, _alpha);
}

// Rotation interpolation method.
// This must be the same Lerp as the one used by the sampling job.
// The goal is to take the shortest path between _a and _b. This code replicates
// this behavior that is actually not done at runtime, but when building the
// animation.
math::Quaternion LerpRotation(const math::Quaternion& _a,
                              const math::Quaternion& _b, float _alpha) {
  // Finds the shortest path. This is done by the AnimationBuilder for runtime
  // animations.
  const float dot = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z + _a.w * _b.w;
  return math::NLerp(_a, dot < 0.f ? -_b : _b, _alpha);  // _b an -_b are the
                                                         // same rotation.
}

// Scale interpolation method.
// This must be the same Lerp as the one used by the sampling job.
math::Float3 LerpScale(const math::Float3& _a, const math::Float3& _b,
                       float _alpha) {
  return math::Lerp(_a, _b, _alpha);
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including animation_builder.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/animation_builder.h"

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstring>
#include <limits>

#include "ozz/base/containers/vector.h"
#include "ozz/base/memory/allocator.h"

#include "ozz/base/maths/simd_math.h"

#include "ozz/animation/offline/raw_animation.h"

#include "ozz/animation/runtime/animation.h"

// Internal include file
#define OZZ_INCLUDE_PRIVATE_HEADER  // Allows to include private headers.

// Includes internal include file animation/runtime/animation_keyframe.h

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#ifndef OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_
#define OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_

#ifndef OZZ_INCLUDE_PRIVATE_HEADER
#error "This header is private, it cannot be included from public headers."
#endif  // OZZ_INCLUDE_PRIVATE_HEADER

namespace ozz {
namespace animation {

// Define animation key frame types (translation, rotation, scale). Every type
// as the same base made of the key time and it's track. This is required as
// key frames are not sorted per track, but sorted by time to favor cache
// coherency.
// Key frame values are compressed, according on their type. Decompression is
// efficient because it's done on SoA data and cached during sampling.

// Defines the translation key frame type.
// Translation values are stored as half precision floats with 16 bits per
// component.
struct TranslationKey {
  float time;
  uint16_t track;
  uint16_t value[3];
};

// Defines the rotation key frame type.
// Rotation value is a quaternion. Quaternion are normalized, which means each
// component is in range [0:1]. This property allows to quantize the 3
// components to 3 signed integer 16 bits values. The 4th component is restored
// at runtime, using the knowledge that |w| = sqrt(1 - (a^2 + b^2 + c^2)).
// The sign of this 4th component is stored using 1 bit taken from the track
// member.
//
// In more details, compression algorithm stores the 3 smallest components of
// the quaternion and restores the largest. The 3 smallest can be pre-multiplied
// by sqrt(2) to gain some precision indeed.
//
// Quantization could be reduced to 11-11-10 bits as often used for animation
// key frames, but in this case RotationKey structure would induce 16 bits of
// padding.
struct RotationKey {
  float time;
  uint16_t track : 13;   // The track this key frame belongs to.
  uint16_t largest : 2;  // The largest component of the quaternion.
  uint16_t sign : 1;     // The sign of the largest component. 1 for negative.
  int16_t value[3];      // The quantized value of the 3 smallest components.
};

// Defines the scale key frame type.
// Scale values are stored as half precision floats with 16 bits per
// component.
struct ScaleKey {
  float time;
  uint16_t track;
  uint16_t value[3];
};
}  // namespace animation
}  // namespace ozz
#endif  // OZZ_ANIMATION_RUNTIME_ANIMATION_KEYFRAME_H_


namespace ozz {
namespace animation {
namespace offline {
namespace {

struct SortingTranslationKey {
  uint16_t track;
  float prev_key_time;
  RawAnimation::TranslationKey key;
};

struct SortingRotationKey {
  uint16_t track;
  float prev_key_time;
  RawAnimation::RotationKey key;
};

struct SortingScaleKey {
  uint16_t track;
  float prev_key_time;
  RawAnimation::ScaleKey key;
};

// Keyframe sorting. Stores first by time and then track number.
template <typename _Key>
bool SortingKeyLess(const _Key& _left, const _Key& _right) {
  return _left.prev_key_time < _right.prev_key_time ||
         (_left.prev_key_time == _right.prev_key_time &&
          _left.track < _right.track);
}

template <typename _SrcKey, typename _DestTrack>
void PushBackIdentityKey(uint16_t _track, float _time, _DestTrack* _dest) {
  typedef typename _DestTrack::value_type DestKey;
  float prev_time = -1.f;
  if (!_dest->empty() && _dest->back().track == _track) {
    prev_time = _dest->back().key.time;
  }
  const DestKey key = {_track, prev_time, {_time, _SrcKey::identity()}};
  _dest->push_back(key);
}

// Copies a track from a RawAnimation to an Animation.
// Also fixes up the front (t = 0) and back keys (t = duration).
template <typename _SrcTrack, typename _DestTrack>
void CopyRaw(const _SrcTrack& _src, uint16_t _track, float _duration,
             _DestTrack* _dest) {
  typedef typename _SrcTrack::value_type SrcKey;
  typedef typename _DestTrack::value_type DestKey;

  if (_src.size() == 0) {  // Adds 2 new keys.
    PushBackIdentityKey<SrcKey, _DestTrack>(_track, 0.f, _dest);
    PushBackIdentityKey<SrcKey, _DestTrack>(_track, _duration, _dest);
  } else if (_src.size() == 1) {  // Adds 1 new key.
    const SrcKey& raw_key = _src.front();
    assert(raw_key.time >= 0 && raw_key.time <= _duration);
    const DestKey first = {_track, -1.f, {0.f, raw_key.value}};
    _dest->push_back(first);
    const DestKey last = {_track, 0.f, {_duration, raw_key.value}};
    _dest->push_back(last);
  } else {  // Copies all keys, and fixes up first and last keys.
    float prev_time = -1.f;
    if (_src.front().time != 0.f) {  // Needs a key at t = 0.f.
      const DestKey first = {_track, prev_time, {0.f, _src.front().value}};
      _dest->push_back(first);
      prev_time = 0.f;
    }
    for (size_t k = 0; k < _src.size(); ++k) {  // Copies all keys.
      const SrcKey& raw_key = _src[k];
      assert(raw_key.time >= 0 && raw_key.time <= _duration);
      const DestKey key = {_track, prev_time, {raw_key.time, raw_key.value}};
      _dest->push_back(key);
      prev_time = raw_key.time;
    }
    if (_src.back().time != _duration) {  // Needs a key at t = _duration.
      const DestKey last = {_track, prev_time, {_duration, _src.back().value}};
      _dest->push_back(last);
    }
  }
  assert(_dest->front().key.time == 0.f && _dest->back().key.time == _duration);
}

void CopyToAnimation(ozz::Vector<SortingTranslationKey>::Std* _src,
                     ozz::Range<TranslationKey>* _dest) {
  const size_t src_count = _src->size();
  if (!src_count) {
    return;
  }

  // Sort animation keys to favor cache coherency.
  std::sort(&_src->front(), (&_src->back()) + 1,
            &SortingKeyLess<SortingTranslationKey>);

  // Fills output.
  const SortingTranslationKey* src = &_src->front();
  for (size_t i = 0; i < src_count; ++i) {
    TranslationKey& key = _dest->begin[i];
    key.time = src[i].key.time;
    key.track = src[i].track;
    key.value[0] = ozz::math::FloatToHalf(src[i].key.value.x);
    key.value[1] = ozz::math::FloatToHalf(src[i].key.value.y);
    key.value[2] = ozz::math::FloatToHalf(src[i].key.value.z);
  }
}

void CopyToAnimation(ozz::Vector<SortingScaleKey>::Std* _src,
                     ozz::Range<ScaleKey>* _dest) {
  const size_t src_count = _src->size();
  if (!src_count) {
    return;
  }

  // Sort animation keys to favor cache coherency.
  std::sort(&_src->front(), (&_src->back()) + 1,
            &SortingKeyLess<SortingScaleKey>);

  // Fills output.
  const SortingScaleKey* src = &_src->front();
  for (size_t i = 0; i < src_count; ++i) {
    ScaleKey& key = _dest->begin[i];
    key.time = src[i].key.time;
    key.track = src[i].track;
    key.value[0] = ozz::math::FloatToHalf(src[i].key.value.x);
    key.value[1] = ozz::math::FloatToHalf(src[i].key.value.y);
    key.value[2] = ozz::math::FloatToHalf(src[i].key.value.z);
  }
}

namespace {
// Compares float absolute values.
bool LessAbs(float _left, float _right) {
  return std::abs(_left) < std::abs(_right);
}

// Compresses quaternion to ozz::animation::RotationKey format.
// The 3 smallest components of the quaternion are quantized to 16 bits
// integers, while the largest is recomputed thanks to quaternion normalization
// property (x^2+y^2+z^2+w^2 = 1). Because the 3 components are the 3 smallest,
// their value cannot be greater than sqrt(2)/2. Thus quantization quality is
// improved by pre-multiplying each componenent by sqrt(2).
void CompressQuat(const ozz::math::Quaternion& _src,
                  ozz::animation::RotationKey* _dest) {
  // Finds the largest quaternion component.
  const float quat[4] = {_src.x, _src.y, _src.z, _src.w};
  const size_t largest = std::max_element(quat, quat + 4, LessAbs) - quat;
  assert(largest <= 3);
  _dest->largest = largest & 0x3;

  // Stores the sign of the largest component.
  _dest->sign = quat[largest] < 0.f;

  // Quantize the 3 smallest components on 16 bits signed integers.
  const float kFloat2Int = 32767.f * math::kSqrt2;
  const int kMapping[4][3] = {{1, 2, 3}, {0, 2, 3}, {0, 1, 3}, {0, 1, 2}};
  const int* map = kMapping[largest];
  const int a = static_cast<int>(floor(quat[map[0]] * kFloat2Int + .5f));
  const int b = static_cast<int>(floor(quat[map[1]] * kFloat2Int + .5f));
  const int c = static_cast<int>(floor(quat[map[2]] * kFloat2Int + .5f));
  _dest->value[0] = math::Clamp(-32767, a, 32767) & 0xffff;
  _dest->value[1] = math::Clamp(-32767, b, 32767) & 0xffff;
  _dest->value[2] = math::Clamp(-32767, c, 32767) & 0xffff;
}
}  // namespace

// Specialize for rotations in order to normalize quaternions.
// Consecutive opposite quaternions are also fixed up in order to avoid checking
// for the smallest path during the NLerp runtime algorithm.
void CopyToAnimation(ozz::Vector<SortingRotationKey>::Std* _src,
                     ozz::Range<RotationKey>* _dest) {
  const size_t src_count = _src->size();
  if (!src_count) {
    return;
  }

  // Normalize quaternions.
  // Also fixes-up successive opposite quaternions that would fail to take the
  // shortest path during the normalized-lerp.
  // Note that keys are still sorted per-track at that point, which allows this
  // algorithm to process all consecutive keys.
  size_t track = std::numeric_limits<size_t>::max();
  const math::Quaternion identity = math::Quaternion::identity();
  SortingRotationKey* src = &_src->front();
  for (size_t i = 0; i < src_count; ++i) {
    math::Quaternion normalized = NormalizeSafe(src[i].key.value, identity);
    if (track != src[i].track) {   // First key of the track.
      if (normalized.w < 0.f) {    // .w eq to a dot with identity quaternion.
        normalized = -normalized;  // Q an -Q are the same rotation.
      }
    } else {  // Still on the same track: so fixes-up quaternion.
      const math::Float4 prev(src[i - 1].key.value.x, src[i - 1].key.value.y,
                              src[i - 1].key.value.z, src[i - 1].key.value.w);
      const math::Float4 curr(normalized.x, normalized.y, normalized.z,
                              normalized.w);
      if (Dot(prev, curr) < 0.f) {
        normalized = -normalized;  // Q an -Q are the same rotation.
      }
    }
    // Stores fixed-up quaternion.
    src[i].key.value = normalized;
    track = src[i].track;
  }

  // Sort.
  std::sort(array_begin(*_src), array_end(*_src),
            &SortingKeyLess<SortingRotationKey>);

  // Fills rotation keys output.
  for (size_t i = 0; i < src_count; ++i) {
    const SortingRotationKey& skey = src[i];
    RotationKey& dkey = _dest->begin[i];
    dkey.time = skey.key.time;
    dkey.track = skey.track;

    // Compress quaternion to destination container.
    CompressQuat(skey.key.value, &dkey);
  }
}
}  // namespace

// Ensures _input's validity and allocates _animation.
// An animation needs to have at least two key frames per joint, the first at
// t = 0 and the last at t = duration. If at least one of those keys are not
// in the RawAnimation then the builder creates it.
Animation* AnimationBuilder::operator()(const RawAnimation& _input) const {
  // Tests _raw_animation validity.
  if (!_input.Validate()) {
    return NULL;
  }

  // Everything is fine, allocates and fills the animation.
  // Nothing can fail now.
  Animation* animation = memory::default_allocator()->New<Animation>();

  // Sets duration.
  const float duration = _input.duration;
  animation->duration_ = duration;
  // A _duration == 0 would create some division by 0 during sampling.
  // Also we need at least to keys with different times, which cannot be done
  // if duration is 0.
  assert(duration > 0.f);  // This case is handled by Validate().

  // Sets tracks count. Can be safely casted to uint16_t as number of tracks as
  // already been validated.
  const uint16_t num_tracks = static_cast<uint16_t>(_input.num_tracks());
  animation->num_tracks_ = num_tracks;
  const uint16_t num_soa_tracks = math::Align(num_tracks, 4);

  // Declares and preallocates tracks to sort.
  size_t translations = 0, rotations = 0, scales = 0;
  for (int i = 0; i < num_tracks; ++i) {
    const RawAnimation::JointTrack& raw_track = _input.tracks[i];
    translations += raw_track.translations.size() + 2;  // +2 because worst case
    rotations += raw_track.rotations.size() + 2;        // needs to add the
    scales += raw_track.scales.size() + 2;              // first and last keys.
  }
  ozz::Vector<SortingTranslationKey>::Std sorting_translations;
  sorting_translations.reserve(translations);
  ozz::Vector<SortingRotationKey>::Std sorting_rotations;
  sorting_rotations.reserve(rotations);
  ozz::Vector<SortingScaleKey>::Std sorting_scales;
  sorting_scales.reserve(scales);

  // Filters RawAnimation keys and copies them to the output sorting structure.
  uint16_t i = 0;
  for (; i < num_tracks; ++i) {
    const RawAnimation::JointTrack& raw_track = _input.tracks[i];
    CopyRaw(raw_track.translations, i, duration, &sorting_translations);
    CopyRaw(raw_track.rotations, i, duration, &sorting_rotations);
    CopyRaw(raw_track.scales, i, duration, &sorting_scales);
  }

  // Add enough identity keys to match soa requirements.
  for (; i < num_soa_tracks; ++i) {
    typedef RawAnimation::TranslationKey SrcTKey;
    PushBackIdentityKey<SrcTKey>(i, 0.f, &sorting_translations);
    PushBackIdentityKey<SrcTKey>(i, duration, &sorting_translations);

    typedef RawAnimation::RotationKey SrcRKey;
    PushBackIdentityKey<SrcRKey>(i, 0.f, &sorting_rotations);
    PushBackIdentityKey<SrcRKey>(i, duration, &sorting_rotations);

    typedef RawAnimation::ScaleKey SrcSKey;
    PushBackIdentityKey<SrcSKey>(i, 0.f, &sorting_scales);
    PushBackIdentityKey<SrcSKey>(i, duration, &sorting_scales);
  }

  // Allocate animation members.
  animation->Allocate(_input.name.length() + 1, sorting_translations.size(),
                      sorting_rotations.size(), sorting_scales.size());

  // Copy sorted keys to final animation.
  CopyToAnimation(&sorting_translations, &animation->translations_);
  CopyToAnimation(&sorting_rotations, &animation->rotations_);
  CopyToAnimation(&sorting_scales, &animation->scales_);

  // Copy animation's name.
  strcpy(animation->name_, _input.name.c_str());

  return animation;  // Success.
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including animation_optimizer.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/animation_optimizer.h"

#include <cassert>
#include <cstddef>

#include "ozz/base/maths/math_constant.h"
#include "ozz/base/maths/math_ex.h"

#include "ozz/animation/offline/raw_animation.h"
#include "ozz/animation/offline/raw_animation_utils.h"

#include "ozz/animation/runtime/skeleton.h"
#include "ozz/animation/runtime/skeleton_utils.h"

namespace ozz {
namespace animation {
namespace offline {

// Setup default values (favoring quality).
AnimationOptimizer::AnimationOptimizer()
    : translation_tolerance(1e-3f),                 // 1 mm.
      rotation_tolerance(.1f * math::kPi / 180.f),  // 0.1 degree.
      scale_tolerance(1e-3f),                       // 0.1%.
      hierarchical_tolerance(1e-3f) {               // 1 mm.
}

namespace {

struct JointSpec {
  float length;
  float scale;
};

typedef ozz::Vector<JointSpec>::Std JointSpecs;

JointSpec Iter(const Skeleton& _skeleton, uint16_t _joint,
               const JointSpecs& _local_joint_specs,
               float _parent_accumulated_scale,
               JointSpecs* _hierarchical_joint_specs) {
  JointSpec local_joint_spec = _local_joint_specs[_joint];
  JointSpec& hierarchical_joint_spec = _hierarchical_joint_specs->at(_joint);
  const Skeleton::JointProperties* properties =
      _skeleton.joint_properties().begin;

  // Applies parent's scale to this joint.
  uint16_t parent = properties[_joint].parent;
  if (parent != Skeleton::kNoParentIndex) {
    local_joint_spec.length *= _parent_accumulated_scale;
    local_joint_spec.scale *= _parent_accumulated_scale;
  }

  if (properties[_joint].is_leaf) {
    // Set leaf length to 0, as track's own tolerance checks are enough for a
    // leaf.
    hierarchical_joint_spec.length = 0.f;
    hierarchical_joint_spec.scale = 1.f;
  } else {
    // Find first child.
    uint16_t child = _joint + 1;
    for (; child < _skeleton.num_joints() && properties[child].parent != _joint;
         ++child) {
    }
    assert(properties[child].parent == _joint);

    // Now iterate childs.
    for (; child < _skeleton.num_joints() && properties[child].parent == _joint;
         ++child) {
      // Entering each child.
      const JointSpec child_spec =
          Iter(_skeleton, child, _local_joint_specs, local_joint_spec.scale,
               _hierarchical_joint_specs);

      // Accumulated each child specs to this joint.
      hierarchical_joint_spec.length =
          math::Max(hierarchical_joint_spec.length, child_spec.length);
      hierarchical_joint_spec.scale =
          math::Max(hierarchical_joint_spec.scale, child_spec.scale);
    }
  }

  // Returns accumulated specs for this joint.
  const JointSpec spec = {
      hierarchical_joint_spec.length + local_joint_spec.length,
      hierarchical_joint_spec.scale * _local_joint_specs[_joint].scale};
  return spec;
}

void BuildHierarchicalSpecs(const RawAnimation& _animation,
                            const Skeleton& _skeleton,
                            JointSpecs* _hierarchical_joint_specs) {
  assert(_animation.num_tracks() == _skeleton.num_joints());

  // Early out if no joint.
  if (_animation.num_tracks() == 0) {
    return;
  }

  // Extracts maximum translations and scales for each track.
  JointSpecs local_joint_specs;
  local_joint_specs.resize(_animation.tracks.size());
  _hierarchical_joint_specs->resize(_animation.tracks.size());

  for (size_t i = 0; i < _animation.tracks.size(); ++i) {
    const RawAnimation::JointTrack& track = _animation.tracks[i];

    float max_length = 0.f;
    for (size_t j = 0; j < track.translations.size(); ++j) {
      max_length =
          math::Max(max_length, LengthSqr(track.translations[j].value));
    }
    local_joint_specs[i].length = std::sqrt(max_length);

    float max_scale = 0.f;
    if (track.scales.size() != 0) {
      for (size_t j = 0; j < track.scales.size(); ++j) {
        max_scale = math::Max(max_scale, track.scales[j].value.x);
        max_scale = math::Max(max_scale, track.scales[j].value.y);
        max_scale = math::Max(max_scale, track.scales[j].value.z);
      }
    } else {
      max_scale = 1.f;
    }
    local_joint_specs[i].scale = max_scale;
  }

  // Iterates all skeleton roots.
  for (uint16_t root = 0;
       root < _skeleton.num_joints() &&
       _skeleton.joint_properties()[root].parent == Skeleton::kNoParentIndex;
       ++root) {
    // Entering each root.
    Iter(_skeleton, root, local_joint_specs, 1.f, _hierarchical_joint_specs);
  }
}

// Copy _src keys to _dest but except the ones that can be interpolated.
template <typename _RawTrack, typename _Comparator, typename _Lerp>
void Filter(const _RawTrack& _src, const _Comparator& _comparator,
            const _Lerp& _lerp, float _tolerance, float _hierarchical_tolerance,
            float _hierarchy_length, _RawTrack* _dest) {
  _dest->reserve(_src.size());

  // Only copies the key that cannot be interpolated from the others.
  size_t last_src_pushed = 0;  // Index (in src) of the last pushed key.
  for (size_t i = 0; i < _src.size(); ++i) {
    // First and last keys are always pushed.
    if (i == 0) {
      _dest->push_back(_src[i]);
      last_src_pushed = i;
    } else if (i == _src.size() - 1) {
      // Don't push the last value if it's the same as last_src_pushed.
      typename _RawTrack::const_reference left = _src[last_src_pushed];
      typename _RawTrack::const_reference right = _src[i];
      if (!_comparator(left.value, right.value, _tolerance,
                       _hierarchical_tolerance, _hierarchy_length)) {
        _dest->push_back(right);
        last_src_pushed = i;
      }
    } else {
      // Only inserts i key if keys in range ]last_src_pushed,i] cannot be
      // interpolated from keys last_src_pushed and i + 1.
      typename _RawTrack::const_reference left = _src[last_src_pushed];
      typename _RawTrack::const_reference right = _src[i + 1];
      for (size_t j = last_src_pushed + 1; j <= i; ++j) {
        typename _RawTrack::const_reference test = _src[j];
        const float alpha = (test.time - left.time) / (right.time - left.time);
        assert(alpha >= 0.f && alpha <= 1.f);
        if (!_comparator(_lerp(left.value, right.value, alpha), test.value,
                         _tolerance, _hierarchical_tolerance,
                         _hierarchy_length)) {
          _dest->push_back(_src[i]);
          last_src_pushed = i;
          break;
        }
      }
    }
  }
  assert(_dest->size() <= _src.size());
}

// Translation filtering comparator.
bool CompareTranslation(const math::Float3& _a, const math::Float3& _b,
                        float _tolerance, float _hierarchical_tolerance,
                        float _hierarchy_scale) {
  if (!Compare(_a, _b, _tolerance)) {
    return false;
  }

  // Compute the position of the end of the hierarchy.
  const math::Float3 s(_hierarchy_scale);
  return Compare(_a * s, _b * s, _hierarchical_tolerance);
}

// Rotation filtering comparator.
bool CompareRotation(const math::Quaternion& _a, const math::Quaternion& _b,
                     float _tolerance, float _hierarchical_tolerance,
                     float _hierarchy_length) {
  // Compute the shortest unsigned angle between the 2 quaternions.
  // diff_w is w component of a-1 * b.
  const float diff_w = _a.x * _b.x + _a.y * _b.y + _a.z * _b.z + _a.w * _b.w;
  const float angle = 2.f * std::acos(math::Min(std::abs(diff_w), 1.f));
  if (std::abs(angle) > _tolerance) {
    return false;
  }

  // Deduces the length of the opposite segment at a distance _hierarchy_length.
  const float arc_length = std::sin(angle) * _hierarchy_length;
  return std::abs(arc_length) < _hierarchical_tolerance;
}

// Scale filtering comparator.
bool CompareScale(const math::Float3& _a, const math::Float3& _b,
                  float _tolerance, float _hierarchical_tolerance,
                  float _hierarchy_length) {
  if (!Compare(_a, _b, _tolerance)) {
    return false;
  }
  // Compute the position of the end of the hierarchy, in both cases _a and _b.
  const math::Float3 l(_hierarchy_length);
  return Compare(_a * l, _b * l, _hierarchical_tolerance);
}
}  // namespace

bool AnimationOptimizer::operator()(const RawAnimation& _input,
                                    const Skeleton& _skeleton,
                                    RawAnimation* _output) const {
  if (!_output) {
    return false;
  }
  // Reset output animation to default.
  *_output = RawAnimation();

  // Validate animation.
  if (!_input.Validate()) {
    return false;
  }

  // Validates the skeleton matches the animation.
  if (_input.num_tracks() != _skeleton.num_joints()) {
    return false;
  }

  // First computes bone lengths, that will be used when filtering.
  JointSpecs hierarchical_joint_specs;
  BuildHierarchicalSpecs(_input, _skeleton, &hierarchical_joint_specs);

  // Rebuilds output animation.
  _output->name = _input.name;
  _output->duration = _input.duration;
  _output->tracks.resize(_input.tracks.size());

  for (size_t i = 0; i < _input.tracks.size(); ++i) {
    Filter(_input.tracks[i].translations, CompareTranslation, LerpTranslation,
           translation_tolerance, hierarchical_tolerance,
           hierarchical_joint_specs[i].scale, &_output->tracks[i].translations);
    Filter(_input.tracks[i].rotations, CompareRotation, LerpRotation,
           rotation_tolerance, hierarchical_tolerance,
           hierarchical_joint_specs[i].length, &_output->tracks[i].rotations);
    Filter(_input.tracks[i].scales, CompareScale, LerpScale, scale_tolerance,
           hierarchical_tolerance, hierarchical_joint_specs[i].length,
           &_output->tracks[i].scales);
  }

  // Output animation is always valid though.
  return _output->Validate();
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including additive_animation_builder.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/additive_animation_builder.h"

#include <cassert>
#include <cstddef>

#include "ozz/animation/offline/raw_animation.h"

namespace ozz {
namespace animation {
namespace offline {

namespace {
template <typename _RawTrack, typename _MakeDelta>
void MakeDelta(const _RawTrack& _src, const _MakeDelta& _make_delta,
               _RawTrack* _dest) {
  _dest->reserve(_src.size());

  // Early out if no key.
  if (_src.empty()) {
    return;
  }

  // Stores reference value.
  typename _RawTrack::const_reference reference = _src[0];

  // Copy animation keys.
  for (size_t i = 0; i < _src.size(); ++i) {
    const typename _RawTrack::value_type delta = {
        _src[i].time, _make_delta(reference.value, _src[i].value)};
    _dest->push_back(delta);
  }
}

math::Float3 MakeDeltaTranslation(const math::Float3& _reference,
                                  const math::Float3& _value) {
  return _value - _reference;
}

math::Quaternion MakeDeltaRotation(const math::Quaternion& _reference,
                                   const math::Quaternion& _value) {
  return _value * Conjugate(_reference);
}

math::Float3 MakeDeltaScale(const math::Float3& _reference,
                            const math::Float3& _value) {
  return _value / _reference;
}
}  // namespace

// Setup default values (favoring quality).
AdditiveAnimationBuilder::AdditiveAnimationBuilder() {}

bool AdditiveAnimationBuilder::operator()(const RawAnimation& _input,
                                          RawAnimation* _output) const {
  if (!_output) {
    return false;
  }
  // Reset output animation to default.
  *_output = RawAnimation();

  // Validate animation.
  if (!_input.Validate()) {
    return false;
  }

  // Rebuilds output animation.
  _output->duration = _input.duration;
  _output->tracks.resize(_input.tracks.size());

  for (size_t i = 0; i < _input.tracks.size(); ++i) {
    MakeDelta(_input.tracks[i].translations, MakeDeltaTranslation,
              &_output->tracks[i].translations);
    MakeDelta(_input.tracks[i].rotations, MakeDeltaRotation,
              &_output->tracks[i].rotations);
    MakeDelta(_input.tracks[i].scales, MakeDeltaScale,
              &_output->tracks[i].scales);
  }

  // Output animation is always valid though.
  return _output->Validate();
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including raw_skeleton.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_skeleton.h"

#include "ozz/animation/runtime/skeleton.h"

namespace ozz {
namespace animation {
namespace offline {

RawSkeleton::RawSkeleton() {}

RawSkeleton::~RawSkeleton() {}

bool RawSkeleton::Validate() const {
  if (num_joints() > Skeleton::kMaxJoints) {
    return false;
  }
  return true;
}

namespace {
struct JointCounter {
  JointCounter() : num_joints(0) {}
  void operator()(const RawSkeleton::Joint&, const RawSkeleton::Joint*) {
    ++num_joints;
  }
  int num_joints;
};
}  // namespace

// Iterates through all the root children and count them.
int RawSkeleton::num_joints() const {
  return IterateJointsDF(JointCounter()).num_joints;
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

// Including raw_skeleton_archive.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/raw_skeleton.h"

#include "ozz/base/io/archive.h"
#include "ozz/base/maths/math_archive.h"

#include "ozz/base/containers/string_archive.h"
#include "ozz/base/containers/vector_archive.h"

namespace ozz {
namespace io {

template <>
void Save(OArchive& _archive, const animation::offline::RawSkeleton* _skeletons,
          size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawSkeleton& skeleton = _skeletons[i];
    _archive << skeleton.roots;
  }
}

template <>
void Load(IArchive& _archive, animation::offline::RawSkeleton* _skeletons,
          size_t _count, uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawSkeleton& skeleton = _skeletons[i];
    _archive >> skeleton.roots;
  }
}

// RawSkeleton::Joint' version can be declared locally as it will be saved from
// this cpp file only.
OZZ_IO_TYPE_VERSION(1, animation::offline::RawSkeleton::Joint)

template <>
void Save(OArchive& _archive,
          const animation::offline::RawSkeleton::Joint* _joints,
          size_t _count) {
  for (size_t i = 0; i < _count; ++i) {
    const animation::offline::RawSkeleton::Joint& joint = _joints[i];
    _archive << joint.name;
    _archive << joint.transform;
    _archive << joint.children;
  }
}

template <>
void Load(IArchive& _archive, animation::offline::RawSkeleton::Joint* _joints,
          size_t _count, uint32_t _version) {
  (void)_version;
  for (size_t i = 0; i < _count; ++i) {
    animation::offline::RawSkeleton::Joint& joint = _joints[i];
    _archive >> joint.name;
    _archive >> joint.transform;
    _archive >> joint.children;
  }
}
}  // namespace io
}  // namespace ozz

// Including skeleton_builder.cc file.

//----------------------------------------------------------------------------//
//                                                                            //
// ozz-animation is hosted at http://github.com/guillaumeblanc/ozz-animation  //
// and distributed under the MIT License (MIT).                               //
//                                                                            //
// Copyright (c) 2017 Guillaume Blanc                                         //
//                                                                            //
// Permission is hereby granted, free of charge, to any person obtaining a    //
// copy of this software and associated documentation files (the "Software"), //
// to deal in the Software without restriction, including without limitation  //
// the rights to use, copy, modify, merge, publish, distribute, sublicense,   //
// and/or sell copies of the Software, and to permit persons to whom the      //
// Software is furnished to do so, subject to the following conditions:       //
//                                                                            //
// The above copyright notice and this permission notice shall be included in //
// all copies or substantial portions of the Software.                        //
//                                                                            //
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR //
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,   //
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL    //
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER //
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING    //
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER        //
// DEALINGS IN THE SOFTWARE.                                                  //
//                                                                            //
//----------------------------------------------------------------------------//

#include "ozz/animation/offline/skeleton_builder.h"

#include <cstring>

#include "ozz/animation/offline/raw_skeleton.h"
#include "ozz/animation/runtime/skeleton.h"
#include "ozz/base/containers/vector.h"
#include "ozz/base/maths/soa_transform.h"
#include "ozz/base/memory/allocator.h"

namespace ozz {
namespace animation {
namespace offline {

namespace {
// Stores each traversed joint to a vector.
struct JointLister {
  explicit JointLister(int _num_joints) { linear_joints.reserve(_num_joints); }
  void operator()(const RawSkeleton::Joint& _current,
                  const RawSkeleton::Joint* _parent) {
    // Looks for the "lister" parent.
    int parent = Skeleton::kNoParentIndex;
    if (_parent) {
      // Start searching from the last joint.
      int j = static_cast<int>(linear_joints.size()) - 1;
      for (; j >= 0; --j) {
        if (linear_joints[j].joint == _parent) {
          parent = j;
          break;
        }
      }
      assert(parent >= 0);
    }
    const Joint listed = {&_current, parent};
    linear_joints.push_back(listed);
  }
  struct Joint {
    const RawSkeleton::Joint* joint;
    int parent;
  };
  // Array of joints in the traversed DAG order.
  ozz::Vector<Joint>::Std linear_joints;
};
}  // namespace

// Validates the RawSkeleton and fills a Skeleton.
// Uses RawSkeleton::IterateJointsBF to traverse in DAG breadth-first order.
// This favors cache coherency (when traversing joints) and reduces
// Load-Hit-Stores (reusing the parent that has just been computed).
Skeleton* SkeletonBuilder::operator()(const RawSkeleton& _raw_skeleton) const {
  // Tests _raw_skeleton validity.
  if (!_raw_skeleton.Validate()) {
    return NULL;
  }

  // Everything is fine, allocates and fills the skeleton.
  // Will not fail.
  Skeleton* skeleton = memory::default_allocator()->New<Skeleton>();
  const int num_joints = _raw_skeleton.num_joints();

  // Iterates through all the joint of the raw skeleton and fills a sorted joint
  // list.
  JointLister lister(num_joints);
  _raw_skeleton.IterateJointsBF<JointLister&>(lister);
  assert(static_cast<int>(lister.linear_joints.size()) == num_joints);

  // Computes name's buffer size.
  size_t chars_size = 0;
  for (int i = 0; i < num_joints; ++i) {
    const RawSkeleton::Joint& current = *lister.linear_joints[i].joint;
    chars_size += (current.name.size() + 1) * sizeof(char);
  }

  // Allocates all skeleton members.
  char* cursor = skeleton->Allocate(chars_size, num_joints);

  // Copy names. All names are allocated in a single buffer. Only the first name
  // is set, all other names array entries must be initialized.
  for (int i = 0; i < num_joints; ++i) {
    const RawSkeleton::Joint& current = *lister.linear_joints[i].joint;
    skeleton->joint_names_[i] = cursor;
    strcpy(cursor, current.name.c_str());
    cursor += (current.name.size() + 1) * sizeof(char);
  }

  // Transfers sorted joints hierarchy to the new skeleton.
  for (int i = 0; i < num_joints; ++i) {
    skeleton->joint_properties_[i].parent = lister.linear_joints[i].parent;
    skeleton->joint_properties_[i].is_leaf =
        lister.linear_joints[i].joint->children.empty();
  }

  // Transfers t-poses.
  const math::SimdFloat4 w_axis = math::simd_float4::w_axis();
  const math::SimdFloat4 zero = math::simd_float4::zero();
  const math::SimdFloat4 one = math::simd_float4::one();

  for (int i = 0; i < skeleton->num_soa_joints(); ++i) {
    math::SimdFloat4 translations[4];
    math::SimdFloat4 scales[4];
    math::SimdFloat4 rotations[4];
    for (int j = 0; j < 4; ++j) {
      if (i * 4 + j < num_joints) {
        const RawSkeleton::Joint& src_joint =
            *lister.linear_joints[i * 4 + j].joint;
        translations[j] =
            math::simd_float4::Load3PtrU(&src_joint.transform.translation.x);
        rotations[j] = math::NormalizeSafe4(
            math::simd_float4::LoadPtrU(&src_joint.transform.rotation.x),
            w_axis);
        scales[j] = math::simd_float4::Load3PtrU(&src_joint.transform.scale.x);
      } else {
        translations[j] = zero;
        rotations[j] = w_axis;
        scales[j] = one;
      }
    }
    // Fills the SoaTransform structure.
    math::Transpose4x3(translations, &skeleton->bind_pose_[i].translation.x);
    math::Transpose4x4(rotations, &skeleton->bind_pose_[i].rotation.x);
    math::Transpose4x3(scales, &skeleton->bind_pose_[i].scale.x);
  }

  return skeleton;  // Success.
}
}  // namespace offline
}  // namespace animation
}  // namespace ozz

